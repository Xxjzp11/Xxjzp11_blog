---
id: 008 Python的列表
title: 008 Python的列表
author: Xxjzp11
author_title: studying
author_url: https://github.com/Xxjzp11
author_image_url: https://avatars2.githubusercontent.com/u/68409850?s=460&u=144d3c818e76fe4b88687db84279fad48b198818&v=4
tags: [python, notes]
---

# 008 Python的列表

<!--truncate-->

------

## 创建列表

### 普通列表

创建一个列表非常简单，我们只需要使用中括号，将所有准备放入列表中的元素给包裹起来，不同元素之间使用逗号分隔：

```ruby
>>> num = [1, 2, 3, 4, 5]
>>> print(num)
[1, 2, 3, 4, 5]
```

### 混合列表

```ruby
>>> mix = [1, '小甲鱼', 3.14, [4, 5]]
>>> print(mix)
[1, '小甲鱼', 3.14, [4, 5]]
```

### 空列表

```ruby
>>> empty = []
>>> empty
[]
```

-------

## 向列表里添加元素

### append()方法

只能有一个参数，在列表的末尾添加一个指定的元素

```ruby
>>> mix.append('test')
>>> print(mix)
[1, '小甲鱼', 3.14, [4, 5], 'test']
```

### extend()方法

也只能有一个参数

extend() 方法的参数必须是一个可迭代对象，然后新的内容是追加到原列表最后一个元素的后面

```ruby
>>> mix.extend(['aa', 'bb'])
>>> print(mix)
[1, '小甲鱼', 3.14, [4, 5], 'tets', 'test', 'aa', 'bb']
```

### insert()方法

有两个参数。

第一个参数表示在列表中的位置，第二个参数表示插入的元素

```ruby
>>> mix.insert(0, 'first')
>>> print(mix)
['first', 1, '小甲鱼', 3.14, [4, 5], 'tets', 'test', 'aa', 'bb']
```

---------

## 从列表中获取元素

跟数组一样，我们可以通过元素的索引值（index）从列表获取单个元素，注意，列表索引值是从 0 开始的。

```ruby
['first', 1, '小甲鱼', 3.14, [4, 5], 'tets', 'test', 'aa', 'bb']
>>> temp = mix [0]
>>> mix[0] = mix[1]
>>> mix[1] = temp
>>> mix
[1, 'first', '小甲鱼', 3.14, [4, 5], 'tets', 'test', 'aa', 'bb']
```

----------

## 从列表中删除元素

### remove()方法

利用 remove() 方法，可以将列表中指定的元素删除：

- 如果列表中存在多个匹配的元素，那么它只会删除第一个
- remove() 方法要求你指定一个待删除的元素，如果指定的元素压根儿不存在，那么程序就会报错

```ruby
>>> mix.remove('小甲鱼')
>>> mix
[1, 'first', 3.14, [4, 5], 'tets', 'test', 'aa', 'bb']
```

### del语句

```ruby
>>> del mix [1]
>>> mix
[1, 3.14, [4, 5], 'tets', 'test', 'aa', 'bb']

# 删除列表
>>> del empty
```

### clear()方法

如果想要一步到位清空列表

```ruby
>>> heros.clear()
>>> heros
[]
```

### pop()方法

如果你没有指定一个参数，那么它“弹”出来的就是最后一个元素：

```ruby
>>> mix.pop()
'bb'
>>> name = mix.pop()
>>> name
'aa'
>>> mix.pop(3)
'tets'
```

---------

## 列表切片

将原先的单个索引值改成一个范围即可实现切片

**[2: 9] 表示索引值为2 - 8 的元素**

```ruby
>>> mix
[1, 3.14, [4, 5], 'test']
>>> mix[1: 3]
[3.14, [4, 5]]
>>> mix[: 3]
[1, 3.14, [4, 5]]
>>> mix[3: ]
['test']
>>> mix[:]
[1, 3.14, [4, 5], 'test']
>>> mix2 = mix[:]
```

```ruby
>>> mix
[1, 3.14, [4, 5], 'test', 10, 11, 'aa', 'bb']
>>> mix[0: 5: 2]
[1, [4, 5], 10]
>>> mix[: : 2]
[1, [4, 5], 10, 'aa']
>>> mix[: : -2]
['bb', 11, 'test', 3.14]
>>> mix[: : -1]
['bb', 'aa', 11, 10, 'test', [4, 5], 3.14, 1]
```

### copy()方法(浅拷贝)

列表还有一个方法叫 copy()，用于拷贝一个列表：

```ruby
>>> nums_copy1 = nums.copy()
>>> nums_copy1
[3, 1, 9, 6, 8, 3, 5, 3]
```

我们也可以使用切片的语法来实现列表拷贝：

```ruby
>>> nums_copy2 = nums[:]
>>> nums_copy2
[3, 1, 9, 6, 8, 3, 5, 3]
```

上面这两种拷贝方法实现的效果是等同的。

这两种拷贝的方法，在 Python 中都称为**浅拷贝**。

### deepcopy() 函数(深拷贝)

浅拷贝：利用列表的 copy() 方法或者切片来实现

深拷贝：利用 copy 模块的 deepcopy() 函数来实现

浅拷贝可以用于处理一维列表，对于嵌套列表的拷贝，只能拷贝第一层数据，其余仅拷贝其引用：

```ruby
>>> x = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> y = x.copy()
>>> x[1][1] = 0
>>> x
[[1, 2, 3], [4, 0, 6], [7, 8, 9]]
>>> y
[[1, 2, 3], [4, 0, 6], [7, 8, 9]]
```

浅拷贝的实现逻辑如下图所示：

![RL5MmF.png](https://z3.ax1x.com/2021/07/08/RL5MmF.png)

深拷贝可以用于处理多维列表

```ruby
>>> x = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> y = copy.deepcopy(x)
>>> x[1][1] = 0
>>> x
[[1, 2, 3], [4, 0, 6], [7, 8, 9]]
>>> y
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
```

深拷贝的实现逻辑如下图所示：

![RL50TH.png](https://z3.ax1x.com/2021/07/08/RL50TH.png)

----------

## 列表元素的修改

列表跟字符串最大区别就是：列表是可变的，而字符串是不可变的。

替换列表中的元素跟访问元素类似，都是使用下标索引的方法，然后使用赋值运算符就可以将新的值给替换进去了：

```ruby
>>> heros = ['蜘蛛侠', '绿巨人', '黑寡妇', '鹰眼', '灭霸', '雷神']
>>> heros[4] = "钢铁侠"
>>> heros
['蜘蛛侠', '绿巨人', '黑寡妇', '鹰眼', '钢铁侠', '雷神']
```

如果有连续的多个元素需要替换，可以利用切片来实现：

```ruby
>>> heros[3:] = ["武松", "林冲", "李逵"]
>>> heros
['蜘蛛侠', '绿巨人', '黑寡妇', '武松', '林冲', '李逵']
```

-----

## 列表元素的查

### count()方法

如果我们想知道 nums 这个列表里面到底有多少个 3，可以使用 count() 方法：

```ruby
>>> nums.count(3)
3
```

### index()方法

如果我们要查找 heros 列表中，"绿巨人"这个元素的索引值，可以使用 index() 方法：

index()方法查找到是范围内第一次出现的索引值

```ruby
>>> heros.index("绿巨人")
4
```

index() 方法有两个可选的参数 —— start 和 end，就是指定查找的开始和结束的下标位置：

```ruby
>>> nums.index(3, 1, 7)
5
```

--------------

## 列表的排序与翻转

### sort() 方法

实现列表从小到大的排序

```ruby
>>> nums = [3, 1, 9, 6, 8, 3, 5, 3]
>>> nums.sort()
>>> nums
[1, 3, 3, 3, 5, 6, 8, 9]
```

### reverse()方法

```ruby
>>> nums.reverse()
>>> nums
[9, 8, 6, 5, 3, 3, 3, 1]
```

sort() 方法还可以实现排序后翻转（即从大到小的排序）：

```ruby
>>> nums = [3, 1, 9, 6, 8, 3, 5, 3]
>>> nums.sort(reverse=True)
#reverse默认为False
>>> nums
[9, 8, 6, 5, 3, 3, 3, 1]
```

----------

## 列表的常用操作符

### 比较

如果有多个元素，默认从第一个元素开始比较，比较对应的ASCII码值大小

```ruby
>>> a = [123, 456]
>>> b = [234, 111]
>>> a > b
False
```

### 加法

列表的加法，其实也是拼接，所以要求加号（+）两边都应该是列表，举个例子

```ruby
>>> s = [1, 2, 3]
>>> t = [4, 5, 6]
>>> s + t
[1, 2, 3, 4, 5, 6]
```

### 乘法

列表的乘法，则是重复列表内部的所有元素若干次

```ruby
>>> s * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
```

--------------

## 嵌套列表

```ruby
>>> matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
```

可以把创建二维列表的语句这么写：

```ruby
>>> matrix = [[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]]
```

这两种写法是等价的，只是后者在理解上更为直观。

### 访问嵌套列表

```ruby
>>> for i in matrix:
		for each in i:
			print(each)

1
2
3
4
5
6
7
8
9
```

或者

```ruby
>>> matrix[0]
[1, 2, 3]
>>> matrix[1]
[4, 5, 6]
>>> matrix[2]
[7, 8, 9]
>>> matrix[0][0]
1
>>> matrix[1][1]
5
>>> matrix[2][2]
9
```

### 通过 for 语句来创建并初始化二维列表

```ruby
>>> A = [0] * 3
>>> for i in range(3):
...     A[i] = [0] * 3
...
>>> A
[[0, 0, 0], [0, 0, 0], [0, 0, 0]]
```

-----------

## 列表推导式

### 基础语法

> [expression for target in iterable]

掌握好列表推导式，会使你的代码变得更为简练和高效。

比如下面这个循环语句：

```ruby
>>> oho = [1, 2, 3, 4, 5]
>>> for i in range(len(oho)):
...     oho[i] = oho[i] * 2
```

写成列表推导式就是：

```ruby
>>> oho = [1, 2, 3, 4, 5]
>>> oho = [i * 2 for i in oho]
```

### 处理矩阵

利用列表推导式处理矩阵也是非常方便，比如下面代码是将矩阵第 2 列的元素给提取出来：

```ruby
>>> matrix = [[1, 2, 3],
...           [4, 5, 6],
...           [7, 8, 9]]
>>> col2 = [row[1] for row in matrix]
>>> col2
[2, 5, 8]
```

又比如，下面代码是获取矩阵主对角线上的元素（就是从左上角到右下角这条对角线上的元素）：

```ruby
>>> diag = [matrix[i][i] for i in range(len(matrix))]
>>> diag
[1, 5, 9]
```

### 创建二维列表

利用列表推导式，就可以很轻松地创建一个二维列表：

```ruby
>>> S = [[0] * 3 for i in range(3)]
>>> S
[[0, 0, 0], [0, 0, 0], [0, 0, 0]]
>>> S[1][1] = 1
>>> S
[[0, 0, 0], [0, 1, 0], [0, 0, 0]]
```

### 带条件筛选功能的列表推导式

列表推导式其实还可以添加一个用于筛选的 if 分句，完整语法如下：

> [expression for target in iterable if condition1]

### 多层嵌套的列表推导式

列表推导式还可以变得更复杂一些，那就是实现嵌套，语法如下：

```ruby
[expression for target1 in iterable1
            for target2 in iterable2
            ...
            for targetN in iterableN]
```

每层嵌套还可以附带一个用于条件筛选的 if 分句：

```ruby
[expression for target1 in iterable1 if condition1
            for target2 in iterable2 if condition2
            ...
            for targetN in iterableN if conditionN]
```

----

## 补充

- 比较两个列表的元素：operator.eq(list1,list2）（前提需import operator）
- 计算列表元素个数：len(list1)
- 返回列表中元素最大值：max(list1)
- 返回列表中元素最小值：min(list1)

- 将元组转换为列表：list(tuple1)

--------------------------

## 测试题一

**0. 列表都可以存放一些什么东西？**

数字、字符串都行、列表

可以存放我们已经学习过的任何数据类型。



**1. 向列表增加元素有哪些方法？**

append()、extend()、insert()



**2. append() 方法和 extend() 方法都是向列表的末尾增加元素，请问他们有什么区别？**

append()只能添加一个元素，extend()可以添加多个元素



**3. member.append(['竹林小溪', 'Crazy迷恋']) 和 member.extend(['竹林小溪', 'Crazy迷恋']) 实现的效果一样吗？**

不一样



**4. 有列表 name = ['F', 'i', 'h', 'C']，如果小甲鱼想要在元素 'i' 和 'h' 之间插入元素 's'，应该使用什么方法来插入？**

name.insert(2, 's')



**5. 自己动手试试看，并分析在这种情况下，向列表添加数据应当采用哪种方法比较好？**

假设给定以下列表：

> member = ['小甲鱼', '黑夜', '迷途', '怡静', '秋舞斜阳']

要求将列表修改为：

> member = ['小甲鱼', 88, '黑夜', 90, '迷途', 85, '怡静', 90, '秋舞斜阳', 88]

**方法一：使用 insert() 和 append() 方法修改列表。**

**方法二：重新创建一个同名字的列表覆盖。**

解答：

方法一：

```bash
member.insert(1, 88)
member.insert(3, 90)
member.insert(5, 85)
member.insert(7, 90)
member.append(88)
```

方法二：

```bash
member = ['小甲鱼', 88, '黑夜', 90, '迷途', 85, '怡静', 90, '秋舞斜阳', 88]
```

对于这种情况，明显是第二种方法看起来要好一些嘛。

不过对于大型的列表，第一种方法可能更合适，所以我们说永远没有最好的，只有最合适的。



**6. 利用 for 循环打印上边 member 列表中的每个内容：**

```bash
>>> member = ['小甲鱼', 88, '黑夜', 90, '迷途', 85, '怡静', 90, '秋舞斜阳', 88]
>>> for each in member:
	print(each, end = ' ')
	
小甲鱼 88 黑夜 90 迷途 85 怡静 90 秋舞斜阳 88
```



**7. 上一题打印的样式不是很好，能不能修改一下代码打印成下图的样式呢？【请至少使用两种方法实现】**

![RL5h7Q.png](https://z3.ax1x.com/2021/07/08/RL5h7Q.png)

方法一：

```python
member = ['小甲鱼', 88, '黑夜', 90, '迷途', 85, '怡静', 90, '秋舞斜阳', 88]
count = 0
length = len(member)
while count < length:
    print(member[count], member[count+1])
    count += 2
```

方法二：

```python
member = ['小甲鱼', 88, '黑夜', 90, '迷途', 85, '怡静', 90, '秋舞斜阳', 88]

for each in range(len(member)):
    if each%2 == 0:
        print(member[each], member[each+1])
#另一种
for each in range(0, len(member), 2):
    print(member[each], member[each+1])
```

--------------

## 测试题二

**0. 下边的列表分片操作会打印什么内容？**

```bash
>>> list1 = [1, 3, 2, 9, 7, 8]
>>> list1[2:5]
```

[2, 9, 7]



**1. 请问 list1[0] 和 list1[0:1] 一样吗？**

不一样，list1[0] 返回第0个元素的值，list1[0:1] 返回一个只含有第0个元素的列表



**2. 如果你每次想从列表的末尾取出一个元素，并将这个元素插入到列表的最前边，你会怎么做？**

> list1.insert(0, list1.pop())



**3. 有些鱼油比较调皮，他说我想试试 list1[-3:-1] 会不会报错，怎么知道一试居然显示 [9, 7]，这是怎么回事呢？**

Python 的列表很聪明，竟然支持负数索引，如图：

![RLIK3t.png](https://z3.ax1x.com/2021/07/08/RLIK3t.png)



**4. 在进行分片的时候，我们知道分片的开始和结束位置需要进行指定，但其实还有另外一个隐藏的设置：步长。**

```bash
>>> list1[0:6:2]
[1, 2, 7]
```

那么依你推测，关于步长的知识点还有哪些（很多知识点都是通用的）？

1.之前提到的“简洁”分片操作在这里有效：

```ruby
>>> list1[::2]
[1, 2, 7]
```

2.步长不能为0，要不就走不动了：

```ruby
>>> list1 = [1, 3, 2, 9, 7, 8]
>>> list1 = [ : : 0 ]
SyntaxError: invalid syntax
```

3.步长可以是负数，改变方向（从尾部开始向左走）：

```ruby
>>> list1[::-2]
[8, 9, 3]
```



**5. 课堂上小甲鱼说可以利用分片完成列表的拷贝 list2 = list1[:]，那事实上可不可以直接写成 list2 = list1 更加简洁呢？**

不可以！

------------------

## 测试题三

**0. 注意，这道题跟上节课的那道题有点儿不同，回答完请上机实验或参考答案。**

```bash
old = [1, 2, 3, 4, 5]
new = old
old = [6]
print(new)
```

如果不上机操作，你觉得会打印什么内容？

[1, 2, 3, 4, 5]



**1. 请问如何将下边这个列表的'小甲鱼'修改为'小鱿鱼'？**

> list1 = [1, [1, 2, ['小甲鱼']], 3, 5, 8, 13, 18]

list1[1]\[2][0] = '小鱿鱼'



**2. 要对一个列表进行顺序排序，请问使用什么方法？**

列表名.sort()



**3. 要对一个列表进行逆序排序，请问使用什么方法？**

列表名.sort(reverse=True)



**4. 请先在 IDLE 中获得下边列表的结果，并按照上方例子把列表推导式还原出来**

> list1 = [(x, y) for x in range(10) for y in range(10) if x%2==0 if y%2!=0]

 答：

```ruby
>>> list1 = [(x, y) for x in range(10) for y in range(10) if x%2==0 if y%2!=0]
>>> list1
[(0, 1), (0, 3), (0, 5), (0, 7), (0, 9), (2, 1), (2, 3), (2, 5), (2, 7), (2, 9), (4, 1), (4, 3), (4, 5), (4, 7), (4, 9), (6, 1), (6, 3), (6, 5), (6, 7), (6, 9), (8, 1), (8, 3), (8, 5), (8, 7), (8, 9)]
>>> list1 = []
>>> for x in range(10):
    for y in range(10):
        if x % 2 == 0:
            if y % 2 != 0:
                list1.append((x, y))

                
>>> list1
[(0, 1), (0, 3), (0, 5), (0, 7), (0, 9), (2, 1), (2, 3), (2, 5), (2, 7), (2, 9), (4, 1), (4, 3), (4, 5), (4, 7), (4, 9), (6, 1), (6, 3), (6, 5), (6, 7), (6, 9), (8, 1), (8, 3), (8, 5), (8, 7), (8, 9)]
```



**5. 活学活用：请使用列表推导式补充被小甲鱼不小心涂掉的部分**

```bash
>>> list1 = ['1.Jost do It','2.一切皆有可能','3.让变成改变世界','4.Impossible is nothing']
>>> list2 = ['4.阿迪达斯','2.李宁','3.鱼C工作室','1.耐克']
>>> list3 = [XXXXXXXXX]
>>> print(list3)
['1.耐克：Jost do It', '2.李宁：一切皆有可能', '3.鱼C工作室：让变成改变世界', '4.阿迪达斯：Impossible is nothing']
>>> for each in list3:
    print(each)
    
1.耐克：Jost do It
2.李宁：一切皆有可能
3.鱼C工作室：让变成改变世界
4.阿迪达斯：Impossible is nothing    
```

答：

> list3 = [name + '：' + slogan[2:] for slogan in list1 for name in list2 if slogan[0] == name[0]]

将list1中的 '1.Jost do It' 也看成一个列表

转换成循环理解

```python
list1 = ['1.Jost do It','2.一切皆有可能','3.让变成改变世界','4.Impossible is nothing']
list2 = ['4.阿迪达斯','2.李宁','3.鱼C工作室','1.耐克']

for slogan in list1:
    for name in list2:
        if slogan[0] == name[0]:
            list3 = name + '：' + slogan[2:]
```



