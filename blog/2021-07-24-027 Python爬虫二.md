---
id: 027 Python爬虫二
title: 027 Python爬虫二
author: Xxjzp11
author_title: studying
author_url: https://github.com/Xxjzp11
author_image_url: https://avatars2.githubusercontent.com/u/68409850?s=460&u=144d3c818e76fe4b88687db84279fad48b198818&v=4
tags: [python, notes]
---

# 027 Python爬虫二

<!--truncate-->

-------

## 正则表达式介绍

正则表达式（Regular expressions 也称为 REs，或 regexes 或 regex patterns）本质上是一个微小的且高度专业化的编程语言。它被嵌入到 Python 中，并通过 re 模块提供给程序猿使用。使用正则表达式，你需要指定一些规则来描述那些你希望匹配的字符串集合。这些字符串集合可能包含英语句子、 e-mail 地址、TeX 命令，或任何你想要的东东。

正则表达式模式被编译成一系列的字节码，然后由一个 C 语言写的匹配引擎所执行。对于高级的使用，你可能需要更关注匹配引擎是如何执行给定的 RE，并通过一定的方式来编写 RE，以便产生一个可以运行得更快的字节码。本文暂不讲解优化的细节，因为这需要你对匹配引擎的内部机制有一个很好的理解。但本文的例子均是符合标准的正则表达式语法。

*小甲鱼注释：Python 的正则表达式引擎是用 C 语言写的，所以效率是极高的。另，所谓的正则表达式，这里说的 RE，就是上文我们提到的“一些规则”。*

正则表达式语言相对较小，并且受到限制，所以不是所有可能的字符串处理任务都可以使用正则表达式来完成。还有一些特殊的任务，可以使用正则表达式来完成，但是表达式会因此而变得非常复杂。在这种情况下，你可能通过自己编写 Python 代码来处理会更好些；尽管 Python 代码比一个精巧的正则表达式执行起来会慢一些，但可能会更容易理解。

------

## 正则表达式详细可参考：

https://www.cnblogs.com/LoveFishC/tag/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/

----

## re模块

### search()方法

```python
>>> import re
>>> re.search(r'FishC', 'I love FishC.com!')
<re.Match object; span=(7, 12), match='FishC'>
```

search() 方法用于在字符串中搜索正则表达式模式第一次出现的位置，如果找到了，匹配的位置是（7，12）

这里需要注意两点：

- **第一个参数是正则表达式模式**，也就是你要描述的搜索规则，需要使用**原始字符串**来写，这样可以避免很多不必要的麻烦
- 找到后返回的范围是以下标0开始的，这跟字符串一样。如果找不到，返回None

------

## 通配符

```python
>>> re.search(r'.', 'I love FishC.com!')
<re.Match object; span=(0, 1), match='I'>
>>> re.search(r'Fish.', 'I love FishC.com!')
<re.Match object; span=(7, 12), match='FishC'>
```

点号（.）来表示可以匹配除了换行符之外的任何字符，其他的后面具体介绍

------

## 反斜杠

```python
>>> re.search(r'\.', 'I love FishC.com!')
<re.Match object; span=(12, 13), match='.'>
```

反斜杠剥夺元字符（.）的特殊能力

```python
>>> re.search(r'\d', 'I love 123 FishC.com!')
<re.Match object; span=(7, 8), match='1'>
```

同样，反斜杠也可以使得普通字符拥有特殊能力

------

## 字符类

```python
>>> re.search(r'[aeiou]', 'I love 123 FishC.com!')
<re.Match object; span=(3, 4), match='o'>
```

使用中括号将任何内容包起来就是一个字符类，它的含义是你只要匹配这个字符类中的任何字符，结果就算作匹配

注意：**默认区分大小写**

```python
>>> re.search(r'[aeiouAEIOU]', 'I love 123 FishC.com!')
<re.Match object; span=(0, 1), match='I'>
>>> re.search(r'[a-z]', 'I love 123 FishC.com!')
<re.Match object; span=(2, 3), match='l'>
>>> re.search(r'[0-2][0-5][0-5]', 'I love 123 FishC.com!')
<re.Match object; span=(7, 10), match='123'>
```

------

## 重复匹配

```python
>>> re.search(r'ab{3}c', 'abbbc')
<re.Match object; span=(0, 5), match='abbbc'>
```

用大括号这个元字符来实现重复匹配的功能。

```python
>>> re.search(r'ab{3}c', 'abbbbbc')
>>> 
```

超过3个或者少于3个都不能匹配。

```python
>>> re.search(r'ab{3,5}c', 'abbbc')
<re.Match object; span=(0, 5), match='abbbc'>
>>> re.search(r'ab{3,5}c', 'abbbbc')
<re.Match object; span=(0, 6), match='abbbbc'>
>>> re.search(r'ab{3,5}c', 'abbbbbc')
<re.Match object; span=(0, 7), match='abbbbbc'>
```

重复的次数也可以取一个范围。

请问如何用正则表达式匹配0~255这个范围的数？？

有些朋友可能想都不想就会这样写：

```python
>>> re.search(r'[0-255]','188')
<_sre.SRE_Match object; span=(0, 1), match='1'>
>>> re.search(r'[0-2][0-5][0-5]','188')
>>> 
```

要注意，[0-255]这个字符类表示0~2还有两个5，所以匹配0125四个数字中任何一个。

正则表达式应该这样写：

```python
>>> re.search(r'[0-1]\d\d|2[0-4]\d|25[0-5]', '188')
<_sre.SRE_Match object; span=(0, 3), match='188'>
```

分几种情况：

> 1.百位可能是0或1，当百位是0或1时，个位和十位任意；
>
> 2.当百位是2时，十位是0-4，个位任意；
>
> 3.当百位是2，十位是5时，个位是0-5；

下面写一个匹配ip地址的：

```python
>>> re.search(r'(([0-1]{0,1}\d{0,1}\d|2[0-4]\d|25[0-5])\.){3}([0-1]{0,1}\d{0,1}\d|2[0-4]\d|25[0-5])','192.168.1.1')
<_sre.SRE_Match object; span=(0, 11), match='192.168.1.1'>
```

其中{3}表示重复3次；其中小括号表示分组的意思，一个小组就是一个整体。{0,1}表示重复0次（没有）或者1次。

-----------

## 编译正则表达式

正则表达式被编译为模式对象，该对象拥有各种方法供你操作字符串，如查找模式匹配或者执行字符串替换。

```python
>>> import re
>>> p = re.compile('ab*')
>>> p  
<_sre.SRE_Pattern object at 0x...>
```

**re.compile()** 也可以接受 flags 参数，用于开启各种特殊功能和语法变化，我们会在后边一一介绍。

现在我们先来看个简单的例子：

```python
p = re.compile('ab*', re.IGNORECASE)
```

正则表达式作为一个字符串参数传给 re.compile()。由于正则表达式并不是 Python 的核心部分，因此没有为它提供特殊的语法支持，所以正则表达式只能以字符串的形式表示。（有些应用根本就不需要使用到正则表达式，所以 Python 社区的小伙伴们认为没有必要将其纳入 Python 的核心。）相反，re 模块仅仅是作为 C 的扩展模块包含在 Python 中，就像 socket 模块和 zlib 模块

------------

## 实现匹配

当你将正则表达式编译之后，你就得到一个模式对象。那你拿他可以用来做什么呢？模式对象拥有很多方法和属性，我们下边列举最重要的几个来讲：

| 方法       | 功能                                                         |
| ---------- | ------------------------------------------------------------ |
| match()    | 判断一个正则表达式是否从开始处匹配一个字符串                 |
| search()   | 遍历字符串，找到正则表达式匹配的第一个位置                   |
| findall()  | 遍历字符串，找到正则表达式匹配的所有位置，并以列表的形式返回 |
| finditer() | 遍历字符串，找到正则表达式匹配的所有位置，并以迭代器的形式返回 |

**如果没有找到任何匹配的话，match() 和 search() 会返回 None；如果匹配成功，则会返回一个匹配对象（match object），包含所有匹配的信息：例如从哪儿开始，到哪儿结束，匹配的子字符串等等**

```python
>>> import re
>>> p = re.compile('[a-z]+')
>>> p
re.compile('[a-z]+')
```

现在，你可以尝试使用正则表达式 [a-z]+ 去匹配各种字符串。

例如：

```python
>>> p.match("")
>>> print(p.match(""))
None
```

因为 + 表示匹配一次或者多次，所以空字符串不能被匹配。因此，match() 返回 None

我们再尝试一个可以匹配的字符串：

```python
>>> m = p.match('fishc')
>>> m 
<_sre.SRE_Match object; span=(0, 5), match='fishc'>
```


在这个例子中，match() 返回一个匹配对象，我们将其存放在变量 m 中，以便日后使用


接下来让我们来看看匹配对象里边有哪些信息吧。匹配对象包含了很多方法和属性，以下几个是最重要的：

| 方法    | 功能                                   |
| ------- | -------------------------------------- |
| group() | 返回匹配的字符串                       |
| start() | 返回匹配的开始位置                     |
| end()   | 返回匹配的结束位置                     |
| span()  | 返回一个元组表示匹配位置（开始，结束） |


大家看：

```python
>>> m.group()
'fishc'
>>> m.start()
0
>>> m.end()
5
>>> m.span()
(0, 5)
```


由于 match() 只检查正则表达式是否在字符串的起始位置匹配，所以 start() 总是返回 0

然而，search() 方法可就不一样咯：

```python
>>> print(p.match('^_^fishc'))
None
>>> m = p.search('^_^fishc')
>>> print(m)
<_sre.SRE_Match object; span=(3, 8), match='fishc'>
>>> m.group()
'fishc'
>>> m.span()
(3, 8)
```


在实际应用中，最常用的方式是将匹配对象存放在一个局部变量中，并检查其返回值是否为 None

形式通常如下：

```python
p = re.compile( ... )
m = p.match( 'string goes here' )
if m:
    print('Match found: ', m.group())
else:
    print('No match')
```

**有两个方法可以返回所有的匹配结果，一个是 findall()，另一个是 finditer()。**

**findall() 返回的是一个列表**：

```python
>>> p = re.compile('\d+')
>>> p.findall('3只小甲鱼，15条腿，多出的3条在哪里？')
['3', '15', '3']
```


findall() 需要在返回前先创建一个列表，而 **finditer() 则是将匹配对象作为一个迭代器返回**：

```python
>>> iterator = p.finditer('3只小甲鱼，15条腿，还有3条去了哪里？')
>>> iterator
<callable_iterator object at 0x10511b588>
>>> for match in iterator:
        print(match.span())
        
(0, 1)
(6, 8)
(13, 14)
```

那我们到底是应该直接使用这些模块级别的函数呢，还是先编译一个模式对象，再调用模式对象的方法呢？这其实取决于正则表达式的使用频率，**如果说我们这个程序只是偶尔使用到正则表达式，那么全局函数是比较方便的；如果我们的程序是大量的使用正则表达式（例如在一个循环中使用），那么建议你使用后一种方法，因为预编译的话可以节省一些函数调用**。但如果是在循环外部，由于得益于内部缓存机制，两者效率相差无几

-------------

## match() VS search()

match() 函数只会检查 RE 是否在字符串的开始处匹配，而 search() 会遍历整个字符串搜索匹配的内容。记住这一区别很重要。再次强调一下，match() 只会报告一次成功的匹配，并且匹配的位置必须是从字符串的第一个字符开始：

```python
>>> print(re.match('super', 'superstition').span())
(0, 5)
>>> print(re.match('super', 'insuperable'))
None
```

另一方面，search() 函数将遍历整个字符串，并报告它找到的第一个匹配：

```python
>>> print(re.search('super', 'superstition').span())
(0, 5)
>>> print(re.search('super', 'insuperable').span())
(2, 7)
```

有时候你可能会耍点小聪明，使用 re.match() 然后在 RE 的前边加上 .*。但尽量不要这么做，最好采用 re.search() 代替。正则表达式编译器会对 REs 做一些分析，以便可以在搜索匹配时提高速度。一般分析会先找到匹配的第一个字符是什么。举个例子，模式 Crow 必须从字符 'C' 开始匹配，那么匹配引擎分析后会快速遍历字符串，然后在 'C' 被找到之后才开始全部匹配。

按照上面的分析，你添加一个 .* 会导致这个优化失败，这就需要从头到尾扫描一遍，然后再回溯匹配 RE 剩余的部分。所以，请使用 re.search() 代替

-------------------

## 编译标志

编译标志让你可以修改正则表达式的工作方式。

在 re 模块下，编译标志均有两个名字：完整名和简写，例如 IGNORECASE 简写是 I（如果你是 Perl 的粉丝，那么你有福了，因为这些简写跟 Perl 是一样的，例如 re.VERBOSE 的简写是 re.X）。另外，多个标志还可以同时使用（通过“|”），如：re.I | re.M 就是同时设置 I 和 M 标志。

下边列举一些支持的编译标志：

| 标志                        | 含义                                                         |
| --------------------------- | ------------------------------------------------------------ |
| ASCII, A                    | 使得转义符号如 \w，\b，\s 和 \d 只能匹配 ASCII 字符          |
| DOTALL, S                   | 使得 . 匹配任何符号，包括换行符                              |
| IGNORECASE, I               | 匹配的时候不区分大小写                                       |
| LOCALE, L                   | 支持当前的语言（区域）设置                                   |
| MULTILINE, M                | 多行匹配，使得 ^ 也匹配换行符之后的位置；$ 也匹配换行符之前的位置 |
| VERBOSE, X (for 'extended') | 启用详细的正则表达式                                         |

下面我们来详细讲解一下它们的含义：

### A，ASCII

**使得 \w，\W，\b，\B，\s 和 \S 只匹配 ASCII 字符，而不匹配完整的 Unicode 字符。**这个标志仅对 Unicode 模式有意义，并忽略字节模式。

### S，DOTALL

**使得 . 可以匹配任何字符，包括换行符。**如果不使用这个标志，. 将匹配除了换行符的所有字符。

### I，IGNORECASE

**字符类和文本字符串在匹配的时候不区分大小写。**举个例子，正则表达式 [A-Z] 也将会匹配对应的小写字母，像 FishC 可以匹配 FishC，fishc 或 FISHC 等。如果你不设置 LOCALE，则不会考虑语言（区域）设置这方面的大小写问题。

### L，LOCALE

**使得 \w，\W，\b 和 \B 依赖当前的语言（区域）环境，而不是 Unicode 数据库。**

区域设置是 C 语言的一个功能，主要作用是消除不同语言之间的差异。例如你正在处理的是法文文本，你想使用 \w+ 来匹配单词，但是 \w 只是匹配 [A-Za-z] 中的单词，并不会匹配 'é' 或 'ç'。如果你的系统正确的设置了法语区域环境，那么 C 语言的函数就会告诉程序 'é' 或 'ç' 也应该被认为是一个字符。当编译正则表达式的时候设置了 LOCALE 的标志，\w+ 就可以识别法文了，但速度多少会受到影响。

### M，MULTILINE

**通常 ^ 只匹配字符串的开头，而 $ 则匹配字符串的结尾。**当这个标志被设置的时候，^ 不仅匹配字符串的开头，还匹配每一行的行首；& 不仅匹配字符串的结尾，还匹配每一行的行尾。

### X，VERBOSE

这个标志使你的正则表达式可以写得更好看和更有条理，因为使用了这个标志，空格会被忽略（除了出现在字符类中和使用反斜杠转义的空格）；这个标志同时允许你在正则表达式字符串中使用注释，# 符号后边的内容是注释，不会递交给匹配引擎（除了出现在字符类中和使用反斜杠转义的 #）。

下边是使用 re.VERBOSE 的例子，大家看下正则表达式的可读性是不是提高了不少：

```python
charref = re.compile(r"""
&[#]                # 开始数字引用
(
     0[0-7]+         # 八进制格式
   | [0-9]+          # 十进制格式
   | x[0-9a-fA-F]+   # 十六进制格式
)
;                   # 结尾分号
""", re.VERBOSE)
```


如果没有设置 VERBOSE 标志，那么同样的正则表达式会写成：

```python
charref = re.compile("&#(0[0-7]+|[0-9]+|x[0-9a-fA-F]+);")
```

------

## 分组

通常在实际的应用过程中，我们除了需要知道一个正则表达式是否匹配之外，还需要更多的信息。对于比较复杂的内容，正则表达式通常使用分组的方式分别对不同内容进行匹配。

下边的例子，我们将 RFC-822 头用“:”号分成名字和值分别匹配：

```python
From: author@example.com
User-Agent: Thunderbird 1.5.0.9 (X11/20061227)
MIME-Version: 1.0
To: editor@example.com
像这种情况，我们就可以写一个正则表达式先来匹配一整个 RFC-822 头，然后利用分组功能，使用一个组来匹配头的名字，另一个组匹配名字对应的值。
```

**在正则表达式中，使用元字符 ( ) 来划分组**。( ) 元字符跟数学表达式中的小括号含义差不多；它们将包含在内部的表达式组合在一起，所以你可以对一个组的内容使用重复操作的元字符，例如 *，+，? 或者 {m, n}。

例如，(ab)* 会匹配零个或者多个 ab：

```python
>>> p = re.compile('(ab)*')
>>> print(p.match('ababababab').span())
(0, 10)
```

**使用 ( ) 表示的子组我们还可以对它进行按层次索引，可以将索引值作为参数传递给这些方法：group()，start()，end() 和 span()**。序号 0 表示第一个分组（这个是默认分组，一直存在的，所以不传入参数相当于默认值 0）：

```python
>>> p = re.compile('(a)b')
>>> m = p.match('ab')
>>> m.group()
'ab'
>>> m.group(0)
'ab'
```

*注释：有几对小括号就是分成了几个子组，例如 (a)(b) 和 (a(b)) 都是由两个子组构成的。*

子组的索引值是从左到右进行编号，子组也允许嵌套，因此我们可以**通过从左往右来统计左括号 ( 来确定子组的序号**。

```python
>>> p = re.compile('(a(b)c)d')
>>> m = p.match('abcd')
>>> m.group(0)
'abcd'
>>> m.group(1)
'abc'
>>> m.group(2)
'b'
```

**group() 方法可以一次传入多个子组的序号**：

```python
>>> m.group(2,1,2)
('b', 'abc', 'b')
```

*小甲鱼解释：start() 是获得参数子组的开始位置；end() 是获得对应子组的结束位置；span() 是获得对应子组的范围。*

**我们还可以通过 groups() 方法一次性返回所有的子组匹配的字符串**：

```python
>>> m.groups()
('abc', 'b')
```


还有一个反向引用的概念需要介绍。反向引用指的是你可以在后面的位置使用先前匹配过的内容，用法是反斜杠加上数字。例如 **\1 表示引用前边成功匹配的序号为 1 的子组**。

```python
>>> p = re.compile(r'(\b\w+)\s+\1')
>>> p.search('Paris in the the spring').group()
'the the'
```


如果只是搜索字符串，反向引用不会被用到，因为很少有文本格式会这样来重复字符。但是，你很快会发现，在字符串替换的时候，反向引用是非常有用的（深井冰）！

*小甲鱼注释：注意，在 Python 的字符串中会使用反斜杠加数字的方式来表示数字的值对应的 ASCII 字符，所以在使用反向索引的正则表达式中，我们依然强调要使用原始字符串。*

---------------------------------------

## 非捕获组

第一个我们要讲的是非捕获组。**有时候你只是需要用一个组来表示部分正则表达式，你并不需要这个组去匹配任何东西，这时你可以通过非捕获组来明确表示你的意图。**非捕获组的语法是 (?:...)，这个 ... 你可以替换为任何正则表达式。

```python
>>> m = re.match("([abc])+", "abc")
>>> m.groups()
('c',)
>>> m = re.match("(?:[abc])+", "abc")
>>> m.groups()
()
```

*小甲鱼解释：**“捕获”就是匹配的意思啦，普通的子组都是捕获组，因为它们能从字符串中匹配到数据**。*

除了你不能从非捕获组获得匹配的内容之外，其他的非捕获组跟普通子组没有什么区别了。你可以在里边放任何东西，使用重复功能的元字符，或者跟其他子组进行嵌套（捕获的或者非捕获的子组都可以）。

当你需要修改一个现有的模式的时候，(?:...) 是非常有用的。原始是添加一个非捕获组并不会影响到其他（捕获）组的序号。值得一提的是，在搜索的速度上，捕获组和非捕获组的速度是没有任何区别的。

-------------------------
## 命名组

我们再来看另外一个重要功能：命名组。普通子组我们使用序列来访问它们，命名组则可以使用一个有意义的名字来进行访问。

命名组的语法是 Python 特有的扩展语法：`(?P\<name>)`。很明显，`< >` 里边的 name 就是命名组的名字啦。命名组除了有一个名字标识之外，跟其他捕获组是一样的。

匹配对象的所有方法不仅可以处理那些由数字引用的捕获组，还可以处理通过字符串引用的命名组。除了使用名字访问，命名组仍然可以使用数字序号进行访问：

```python
>>> p = re.compile(r'(?P<word>\b\w+\b)')
>>> m = p.search( '(((( Lots of punctuation )))' )
>>> m.group('word')
'Lots'
>>> m.group(1)
'Lots'
```

命名组非常好用，因为它让你可以使用一个好记的名字代替一些毫无意义的数字。下边是来自 imaplib 模块的例子：

```python
InternalDate = re.compile(r'INTERNALDATE "'
        r'(?P<day>[ 123][0-9])-(?P<mon>[A-Z][a-z][a-z])-'
        r'(?P<year>[0-9][0-9][0-9][0-9])'
        r' (?P<hour>[0-9][0-9]):(?P<min>[0-9][0-9]):(?P<sec>[0-9][0-9])'
        r' (?P<zonen>[-+])(?P<zoneh>[0-9][0-9])(?P<zonem>[0-9][0-9])'
        r'"')
```

很明显，使用 `m.group('zonem')` 访问匹配内容要比使用数字 9 更简单明了。

**正则表达式中，反向引用的语法像 (...)\1 是使用序号的方式来访问子组；在命名组里，显然也是有对应的变体：使用名字来代替序号。其扩展语法是 (?P=name)，含义是该 name 指向的组需要在当前位置再次引用。**那么搜索两个单词的正则表达式可以写成 `(\b\w+)\s+\1`，也可以写成 `(?P\<word>\b\w+)\s+(?P=word)`

```python
>>> p = re.compile(r'(?P<word>\b\w+)\s+(?P=word)')
>>> p.search('Paris in the the spring').group()
'the the'
```

-------

## 修改字符串

我们已经介绍完如何对字符进行搜索，接下来我们讲讲正则表达式如何修改字符串。

正则表达式使用以下方法修改字符串：

| 方法    | 用途                                                  |
| ------- | ----------------------------------------------------- |
| split() | 在正则表达式匹配的地方进行分割，并返回一个列表        |
| sub()   | 找到所有匹配的子字符串，并替换为新的内容              |
| subn()  | 跟 sub() 干一样的勾当，但返回新的字符串以及替换的数目 |

### 分割字符串

正则表达式的 split() 方法将字符串在匹配的地方进行分割，并将分割后的结果作为列表返回。它的做法其实很像字符串的 split() 方法，但这个可以使用更加广泛的分隔符。你猜的没错，它同时提供了一个模块级别的函数：re.split()

**.split(*string*[, *maxsplit=0*])**

通过正则表达式匹配来分割字符串。如果在 RE 中，你使用了捕获组，那么它们的内容会作为一个列表返回。你可以通过传入一个 *maxsplit* 参数来设置分割的数量。**如果 *maxsplit* 的值是非 0，表示至多有 *maxsplit* 个分割会被处理，剩下的内容作为列表的最后一个元素返回**。

下边例子中，分隔符是任何非字母数字字符：

```python
>>> p = re.compile(r'\W+')
>>> p.split('This is a test, short and sweet, of split().')
['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', '']
>>> p.split('This is a test, short and sweet, of split().', 3)
['This', 'is', 'a', 'test, short and sweet, of split().']
```

有时候你可能不仅对分隔符之间的内容感兴趣，你可能对分隔符本身（就是正则表达式匹配的内容）也同样感兴趣。如果使用了捕获组，那么作为分隔符的值也会被返回：

```python
>>> p = re.compile(r'\W+')
>>> p2 = re.compile(r'(\W+)')
>>> p.split('This... is a test.')
['This', 'is', 'a', 'test', '']
>>> p2.split('This... is a test.')
['This', '... ', 'is', ' ', 'a', ' ', 'test', '.', '']
```


模块级别的函数 re.split() 除了将 RE 作为第一个参数外，其他参数是一样的：

```python
>>> re.split('[\W]+', 'Words, words, words.')
['Words', 'words', 'words', '']
>>> re.split('([\W]+)', 'Words, words, words.')
['Words', ', ', 'words', ', ', 'words', '.', '']
>>> re.split('[\W]+', 'Words, words, words.', 1)
['Words', 'words, words.']
```

### 搜索和替换

另一个常见的任务就是找到所有的匹配部分，并替换成不同的字符串。sub 方法可以帮你实现这个愿望！sub 方法有一个*replacement* 参数，它可以是一个待替换的字符串，或者一个处理字符串的函数。

**.sub(*replacement*, *string*[, *count=0*])**

**返回一个字符串，这个字符串从最左边开始，所有 RE 匹配的地方都替换成 *replacement*。如果没有找到任何匹配，那么返回原字符串**。

**可选参数 *count* 指定最多替换的次数，必须是一个非负值。默认值是 0，意思是替换所有找到的匹配。**

下边是使用 sub() 方法的例子，它会将所有的颜色替换成 color：

```python
>>> p = re.compile( '(blue|white|red)')
>>> p.sub( 'colour', 'blue socks and red shoes')
'colour socks and colour shoes'
>>> p.sub( 'colour', 'blue socks and red shoes', count=1)
'colour socks and red shoes'
```

**subn() 方法跟 sub() 方法干同样的勾当，但区别是返回值为一个包含有两个元素的元组：一个是替换后的字符串，一个是替换的数目。**

```python
>>> p = re.compile( '(blue|white|red)')
>>> p.subn( 'colour', 'blue socks and red shoes')
('colour socks and colour shoes', 2)
>>> p.subn( 'colour', 'no colours at all')
('no colours at all', 0)
```

**空匹配只有在它们没有紧挨着前一个匹配时才会被替换掉：**

```python
>>> p = re.compile('x*')
>>> p.sub('-', 'abxd')
'-a-b-d-'
```

如果 *replacement* 参数是一个字符串，那么里边的反斜杠都会被处理。比如 \n 将会被转换成一个换行符，\r 转换成回车，等等。未知的转义如 \j 保持原样。逆向引用如 \6，则被 RE 中相应的捕获组匹配的内容所替换。这使你可以在替换后的字符串中插入一部分原字符串。

下边例子中，将匹配被 { 和 } 括起来的单词 section，并将 section 替换成 subsection：

```python
>>> p = re.compile('section{ ( [^}]* ) }', re.VERBOSE)
>>> p.sub(r'subsection{\1}','section{First} section{second}')
'subsection{First} subsection{second}'
```

小甲鱼解释：

1.大家还记得吗？这里开启了re.VERBOSE，空格将被忽略。因为这里一堆符号，用空格隔开看着才不会乱糟糟的......

2.这里r'subsection{\1}'使用\1引用匹配模式中的`([^}]\*)`匹配的字符串内容。

还可以使用**Python的扩展语法(?P\<name>...)指定命名组，引用命名组的语法是\g\<name>。\g\<name>会将名字为name的组匹配的字符串替换进去。**另外，\g<数字>是通过组的序号进行引用。\g<2>其实就相当于\2，但我们更提倡使用\g<2>，因为这样可以避免歧义。例如，\g<2>0的含义是引用序号为2的组，然后后边匹配一个字符'0'，而你写成\20就会被认为是引用序号为20的组了。

```python
>>> p = re.compile('section{ (?P<name> [^}]* ) }', re.VERBOSE)
>>> p.sub(r'subsection{\1}','section{First}')
'subsection{First}'
>>> p.sub(r'subsection{\g<1>}','section{First}')
'subsection{First}'
>>> p.sub(r'subsection{\g<name>}','section{First}')
'subsection{First}'
```

有时候你可能不满足简单的字符串替换，你可能需要在替换的过程中动点“手脚”......没关系，一样可以满足你！*replacement* 参数还可以是一个函数，该函数将会在正则表达式模式每次不重复匹配的时候被调用。在每次调用时，函数会收到一个匹配对象的参数，因此你就可以利用这个对象去计算出新的字符串并返回它。

下边的例子中，替换函数将十进制数替换为十六进制数：

```python
>>> def hexrepl(match):
...     "Return the hex string for a decimal number"
...     value = int(match.group())
...     return hex(value)
...
>>> p = re.compile(r'\d+')
>>> p.sub(hexrepl, 'Call 65490 for printing, 49152 for user code.')
'Call 0xffd2 for printing, 0xc000 for user code.'
```


当使用模块级的 re.sub() 函数时，正则表达式模式作为第一个参数。该模式可以是一个字符串或一个编译好的对象。如果你需要指定正则表达式标志，那么你必须使用后者；或者使用模式内嵌修正器，例如 sub("(?i)b+", "x", "bbbb BBBB") 返回 'x x'。

----------------------

## 贪婪 VS 非贪婪

当重复一个正则表达式时，如果使用 a*，那么结果是尽可能多地去匹配。当你尝试匹配一对对称的定界符，例如 HTML 标志中的尖括号，默认的贪婪模式会使得你很困扰。

我们来看下例子：

```python
>>> s = '<html><head><title>Title</title>'
>>> len(s)
32
>>> print(re.match('<.*>', s).span())
(0, 32)
>>> print(re.match('<.*>', s).group())
<html><head><title>Title</title>
```

RE 匹配在\<html> 的 < 后，.* 消耗掉字符串的剩余部分。由于正则表达式默认是贪婪的原因，RE 必须从字符串的尾部一个字符一个字符地回溯，直到找到匹配的 >。大家看到，按照这种方法，最后找到匹配内容竟是\<html> 的 < 开始，到\</title> 的 > 结束。显然这不是你想要的结果。

在这种情况下，解决方案是使用非贪婪的限定符 *?、+?、?? 或 {m, n}?，尽可能地匹配小的文本。

```python
>>> print(re.match('<.*?>', s).group())
<html>
```


在上边的例子中，> 在第一个 < 被匹配后立刻尝试匹配，如果失败，匹配引擎前进一步，尝试下一个字符，直到第一次匹配 >，这样就得到了我们想要的结果。

注意，使用正则表达式分析 HTML 和 XML 是很痛苦的。当你编写一个正则表达式去处理所有可能的情况时，你会发现 HTML 和 XML 总会打破你的“规则”，这让你很头疼......像这样的话，建议使用 HTML 和 XML 解析器来处理更合适。

------------------------

## 特殊符号及用法总结

正则表达式所有的元字符

- `.  ^  $  *  +  ?  {}  []  \   |  ()`

为了便于理解，难点的地方均用*斜体*举了例子

| **字符**                            | **含义**                                                     |
| ----------------------------------- | ------------------------------------------------------------ |
| .                                   | 表示匹配除了换行符外的任何字符 <br/>注：通过设置 re.DOTALL 标志可以使 `.` 匹配任何字符（包含换行符） |
| \|                                  | `A | B`，表示匹配正则表达式 A 或者 B                         |
| ^                                   | 1. （脱字符）匹配输入字符串的开始位置 <br/>2. 如果设置了 re.MULTILINE 标志，`^` 也匹配换行符之后的位置 |
| $                                   | 1. 匹配输入字符串的结束位置 <br/>2. 如果设置了 re.MULTILINE 标志，`$` 也匹配换行符之前的位置 |
| \                                   | 1. 将一个普通字符变成特殊字符，例如 `\d` 表示匹配所有十进制数字 <br/>2. 解除元字符的特殊功能，例如 `\.` 表示匹配点号本身 <br/>3. 引用序号对应的子组所匹配的字符串 <br/>4. 详见下方列举 |
| [...]                               | 字符类，匹配所包含的任意一个字符 <br/>注1：连字符 `-` 如果出现在字符串中间表示字符范围描述；如果如果出现在首位则仅作为普通字符 <br/>注2：特殊字符仅有反斜线 `\` 保持特殊含义，用于转义字符。其它特殊字符如 `*`、`+`、`?` 等均作为普通字符匹配 <br/>注3：脱字符 `^` 如果出现在首位则表示匹配不包含其中的任意字符；如果 `^` 出现在字符串中间就仅作为普通字符匹配 |
| {M,N}                               | M 和 N 均为非负整数，其中 M <= N，表示前边的 RE 匹配 M ~ N 次 <br/>注1：{M,} 表示至少匹配 M 次 <br/>注2：{,N} 等价于 {0,N} <br/>注3：{N} 表示需要匹配 N 次 |
| *                                   | 匹配前面的子表达式零次或多次，等价于 {0,}                    |
| +                                   | 匹配前面的子表达式一次或多次，等价于 {1,}                    |
| ?                                   | 匹配前面的子表达式零次或一次，等价于 {0,1}                   |
| *?, +?, ??                          | 默认情况下 `*`、`+` 和 `?` 的匹配模式是贪婪模式（即会尽可能多地匹配符合规则的字符串）；`*?`、`+?` 和 `??` 表示启用对应的非贪婪模式。 <br/>*举个栗子：对于字符串 "FishCCC"，正则表达式 `FishC+` 会匹配整个字符串，而 `FishC+?` 则匹配 "FishC"。* |
| {M,N}?                              | 同上，启用非贪婪模式，即只匹配 M 次                          |
| (...)                               | 匹配圆括号中的正则表达式，或者指定一个子组的开始和结束位置 <br/>注：子组的内容可以在匹配之后被 `\数字` 再次引用 <br/>*举个栗子： `(\w+) \1` 可以字符串 "FishC FishC.com" 中的 "FishC FishC"（注意有空格）* |
| (?...)                              | `(?` 开头的表示为正则表达式的扩展语法（下边这些是 Python 支持的所有扩展语法） |
| (?aiLmsux)                          | 1. (? 后可以紧跟着 'a'，'i'，'L'，'m'，'s'，'u'，'x' 中的一个或多个字符，只能在正则表达式的开头使用 <br/>2. 每一个字符对应一种匹配标志：re-A（只匹配 ASCII 字符），re-I（忽略大小写），re-L（区域设置），re-M（多行模式）, re-S（. 匹配任何符号），re-X（详细表达式），包含这些字符将会影响整个正则表达式的规则 <br/>3. 当你不想通过 re.compile() 设置正则表达式标志，这种方法就非常有用啦 注意，由于 `(?x)` 决定正则表达式如何被解析，所以它应该总是被放在最前边（最多允许前边有空白符）。如果 (?x) 的前边是非空白字符，那么 (?x) 就发挥不了作用了。 |
| (?:...)                             | 非捕获组，即该子组匹配的字符串无法从后边获取                 |
| (?P\<name>...)                      | 命名组，通过组的名字（name）即可访问到子组匹配的字符串       |
| (?P=name)                           | 反向引用一个命名组，它匹配指定命名组匹配的任何内容           |
| (?#...)                             | 注释，括号中的内容将被忽略                                   |
| (?=...)                             | 前向肯定断言。如果当前包含的正则表达式（这里以 ... 表示）在当前位置成功匹配，则代表成功，否则失败。一旦该部分正则表达式被匹配引擎尝试过，就不会继续进行匹配了；剩下的模式在此断言开始的地方继续尝试。<br/> *举个栗子：`love(?=FishC)` 只匹配后边紧跟着 "FishC" 的字符串 "love"* |
| (?!...)                             | 前向否定断言。这跟前向肯定断言相反（不匹配则表示成功，匹配表示失败）。 <br/>*举个栗子：`FishC(?!\.com)` 只匹配后边不是 ".com" 的字符串 "FishC"* |
| (?<=...)                            | 后向肯定断言。跟前向肯定断言一样，只是方向相反。 <br/>*举个栗子：`(?<=love)FishC` 只匹配前边紧跟着 "love" 的字符串 "FishC"* |
| (?<!...)                            | 后向否定断言。跟前向肯定断言一样，只是方向相反。<br/> *举个栗子：`(?<!FishC)\.com` 只匹配前边不是 "FishC" 的字符串 ".com"* |
| (?(id/name)yes-pattern\|no-pattern) | 1. 如果子组的序号或名字存在的话，则尝试 yes-pattern 匹配模式；否则尝试 no-pattern 匹配模式 <br/>2. no-pattern 是可选的 <br/>*举个栗子：`(<)?(\w+@\w+(?:\.\w+)+)(?(1)>|$)` 是一个匹配邮件格式的正则表达式，可以匹配\<user@fishc.com> 和 'user@fishc.com'，但是不会匹配 '\<user@fishc.com' 或 'user@fishc.com>'* |
| \                                   | 下边列举了由字符 `'\'` 和另一个字符组成的特殊含义。注意，`'\' + 元字符`的组合可以解除元字符的特殊功能 |
| \序号                               | 1. 引用序号对应的子组所匹配的字符串，子组的序号从 1 开始计算 <br/>2. 如果序号是以 0 开头，或者 3 个数字的长度。那么不会被用于引用对应的子组，而是用于匹配八进制数字所表示的 ASCII 码值对应的字符 <br/>*举个栗子：`.+) \1` 会匹配 "FishC FishC" 或 "55 55"，但不会匹配 "FishCFishC"（注意，因为子组后边还有一个空格）* |
| \A                                  | 匹配输入字符串的开始位置                                     |
| \Z                                  | 匹配输入字符串的结束位置                                     |
| \b                                  | 零宽断言，匹配一个单词边界，单词被定义为 Unidcode 的字母数字或下横线字符 <br/>*举个栗子：`\bFishC\b` 会匹配字符串 "love FishC"、FishC." 或 "(FishC)"* |
| \B                                  | 零宽断言，匹配非单词边界，其实就是与 \b 相反 <br/>*举个栗子：`py\B` 会匹配字符串 "python"、"py3" 或 "py2"，但不会匹配 "py "、"py." 或 "py!"* |
| \d                                  | 1. 对于 Unicode（str 类型）模式：匹配任何一个数字，包括 [0-9] 和其他数字字符；如果开启了 re.ASCII 标志，就只匹配 [0-9] <br/>2. 对于 8 位（bytes 类型）模式：匹配 [0-9] 中任何一个数字 |
| \D                                  | 匹配任何非 Unicode 的数字，其实就是与 \d 相反；如果开启了 re.ASCII 标志，则相当于匹配 `[^0-9]` |
| \s                                  | 1. 对于 Unicode（str 类型）模式：匹配 Unicode 中的空白字符（包括 [ \t\n\r\f\v] 以及其他空白字符）；如果开启了 re.ASCII 标志，就只匹配 [ \t\n\r\f\v] <br/>2. 对于 8 位（bytes 类型）模式：匹配 ASCII 中定义的空白字符，即 [ \t\n\r\f\v] |
| \S                                  | 匹配任何非 Unicode 中的空白字符，其实就是与 \s 相反；如果开启了 re.ASCII 标志，则相当于匹配 `[^ \t\n\r\f\v]` |
| \w                                  | 1. 对于 Unicode（str 类型）模式：匹配任何 Unicode 的单词字符，基本上所有语言的字符都可以匹配，当然也包括数字和下横线；如果开启了 re.ASCII 标志，就只匹配 `[a-zA-Z0-9_]` <br/>2. 对于 8 位（bytes 类型）模式：匹配 ASCII 中定义的字母数字，即 `[a-zA-Z0-9_]` |
| \W                                  | 匹配任何非 Unicode 的单词字符，其实就是与 \w 相反；如果开启了 re.ASCII 标志，则相当于 `[^a-zA-Z0-9_]` |
| 转义符号                            | 正则表达式还支持大部分 Python 字符串的转义符号：\a，\b，\f，\n，\r，\t，\u，\U，\v，\x，\\ <br/>注1：\b 通常用于匹配一个单词边界，只有在字符类中才表示“退格” <br/>注2：\u 和 \U 只有在 Unicode 模式下才会被识别 <br/>注3：八进制转义（\数字）是有限制的，如果第一个数字是 0，或者如果有 3 个八进制数字，那么就被认为是八进制数；其他情况则被认为是子组引用；至于字符串，八进制转义总是最多只能是 3 个数字的长度 |















