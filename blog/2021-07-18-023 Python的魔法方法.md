---
id: 023 Python的魔法方法
title: 023 Python的魔法方法
author: Xxjzp11
author_title: studying
author_url: https://github.com/Xxjzp11
author_image_url: https://avatars2.githubusercontent.com/u/68409850?s=460&u=144d3c818e76fe4b88687db84279fad48b198818&v=4
tags: [python, notes]
---

# 023 Python的魔法方法

<!--truncate-->

------------------

- 魔法方法总是被双下划线包围，例如`__init__`
- 魔法方法是面向对象的Python的一切，如果你不知道魔法方法，说明你还没能意识到面向对象的Python的强大
- 魔法方法的“魔力”体现在它们总能够在适当的时候被调用

## 构造方法

### _\_init__(self[, ...])

**这个方法一般用于初始化一个类**

但是，当实例化一个类的时候, `__init__()`并不是第一个被调用的, 第一个被调用的是`__new__()`

```python
class Test(object):
    """
    用于初始化类
    """
    def __init__(self, a, b):
        self.a = a
        self.b = b
```

一般在需要进行初始化的时候才重写`__init__()`方法。**而且要记住该方法的返回值一定是None（或者也可以理解没有返回值）**

### _\_new__(cls[, ...])

**`__new__()`方法是创建类实例的方法, 创建对象时调用, 返回当前对象的一个实例**。下面是当继承一个不可变的类型的时候，它的特征就显得尤为重要了。

```ruby
>>> class CapStr(str):
      def __new__(cls, string):
          string = string.upper()
          return str.__new__(cls, string)
      
>>> a = CapStr("I love Fishc")    
>>> a     
'I LOVE FISHC'
```

再看一段代码：

```python
class Demo(object):
    def __init__(self):
        print('__init__() called...')

    def __new__(cls, *args, **kwargs):
        print('__new__() - {cls}'.format(cls=cls))
        return object.__new__(cls, *args, **kwargs)

if __name__ == '__main__':
    de = Demo()
```

输出：

```kotlin
__new__() - <class '__main__.Demo'>
__init__() called...
```

发现实例化对象的时候，调用`__init__()`初始化之前，先调用了`__new__()`方法

**`__new__()`必须要有返回值，返回实例化出来的实例，需要注意的是，可以return父类`__new__()`出来的实例，也可以直接将object的`__new__()`出来的实例返回**

 **`__init__()`有一个参数self，该self参数就是`__new__()`返回的实例，`__init__()`在`__new__()`的基础上可以完成一些其它初始化的动作，`__init__()`不需要返回值**。

若`__new__()`没有正确返回当前类cls的实例，那`__init__()`将不会被调用，即使是父类的实例也不行

我们可以将类比作制造商，`__new__()`方法就是前期的原材料购买环节，`__init__()`方法就是在有原材料的基础上，加工，初始化商品环节

------

## 析构方法

### _\_del__(self)

**该方法是当垃圾回收机制回收这个对象时调用的**。举个例子：

```ruby
>>> class C:
      def __init__(self):
          print("我是__init__方法，我被调用了")
      def __del__(self):
          print("我是__del__方法，我被调用了")

>>> c1 = C()      
我是__init__方法，我被调用了
>>> c2 = c1   
>>> c3 = c2
>>> del c1    
>>> del c2    
>>> del c3
我是__del__方法，我被调用了
```

**只有当一个对象以及这个对象的所有引用都被删除之后才会调用`__del__()`方法**

这里补充下Python垃圾回收机制的内容：

- Python中的垃圾回收是以引用计数为主，分代收集为辅。引用计数的缺陷是循环引用的问题。
- 在Python中，如果一个对象的引用数为0，Python虚拟机就会回收这个对象的内存。

- 具体关于垃圾回收可参考：http://www.cnblogs.com/Xjng/p/5128269.html

--------------------

## 工厂函数：

**其实就是一个类对象，被调用的时候，事实上就是创建一个相应的实例对象**。就是：

```ruby
>>> type(int)
<class 'type'>
>>> type(dir)
<class 'type'>
>>> type(list)
<class 'type'>
>>> class C:
       pass
>>> type(C)
<class 'type'>
```

---------------------

## 算数运算相关的魔法方法

| 运算符       | 对应的魔法方法                 | 中文注释                                   |
| ------------ | ------------------------------ | ------------------------------------------ |
| +            | _\_add__(self, other)          | 加法                                       |
| -            | _\_sub__(self, other)          | 减法                                       |
| *            | _\_mul__(self, other)          | 乘法                                       |
| /            | _\_truediv__(self, other)      | 真除法                                     |
| //           | _\_floordiv__(self, other)     | 整数除法                                   |
| %            | _\_mod__(self, other)          | 取余除法                                   |
| divmod(a, b) | _\_divmod__(self, other)       | divmod(a, b)返回的值是一个元组 (a//b, a%b) |
| **           | _\_pow__(self, other[,modulo]) | self的other次方再对modulo取余              |
| <<           | _\_lshift__(self, other)       | 按位左移                                   |
| >>           | _\_rshift__(self, other)       | 按位右移                                   |
| &            | _\_and__(self, other)          | 按位与操作                                 |
| ^            | _\_xor__(self, other)          | 按位异或操作(同为0，异为1)                 |
| 丨           | _\_or__(self, other)           | 按位或操作(有1则1)                         |

------

## 反运算相关的魔法方法

| 魔法方法                    | 定义                                                         |
| --------------------------- | ------------------------------------------------------------ |
| __ radd__(self, other)      | 定义加法的行为：+（当左操作数不支持相应的操作时被调用）      |
| __ rsub__(self, other)      | 定义减法的行为：-（当左操作数不支持相应的操作时被调用）      |
| __ rmul__(self, other)      | 定义乘法的行为：*（当左操作数不支持相应的操作时被调用）      |
| __ rtruediv__(self, other)  | 定义真除法的行为：/（当左操作数不支持相应的操作时被调用）    |
| __ rfloordiv__(self, other) | 定义整数除法的行为：//（当左操作数不支持相应的操作时被调用） |
| __ rmod__(self, other)      | 定义取模算法的行为：%（当左操作数不支持相应的操作时被调用）  |
| __ rdivmod__(self, other)   | 定义当被divmod()调用时的行为（当左操作数不支持相应的操作时被调用） |
| __ rpow__(self, other)      | 定义当被power()调用或**运算时的行为（当左操作数不支持相应的操作时被调用） |
| __ rlshift__(self, other)   | 定义按位左移位的行为：<<（当左操作数不支持相应的操作时被调用） |
| __ rrshift__(self, other)   | 定义按位右移位的行为：>>（当左操作数不支持相应的操作时被调用） |
| __ rand__(self, other)      | 定义按位与操作的行为：&（当左操作数不支持相应的操作时被调用） |
| __ rxor__(self, other)      | 定义按位异或操作的行为：^（当左操作数不支持相应的操作时被调用） |
| __ ror__(self, other)       | 定义按位或操作的行为：丨（当左操作数不支持相应的操作时被调用） |

**重写反运算魔法方法的时候，一定要注意操作数的顺序！**

------

## 增量赋值运算的魔法方法

| 魔法方法                    | 定义                           |
| --------------------------- | ------------------------------ |
| __ iadd__(self, other)      | 定义赋值加法的行为：+=         |
| __ isub__(self, other)      | 定义赋值减法的行为：-=         |
| __ imul__(self, other)      | 定义赋值乘法的行为：*=         |
| __ itruediv__(self, other)  | 定义赋值真除法的行为：/=       |
| __ ifloordiv__(self, other) | 定义赋值整数除法的行为：//=    |
| __ imod__(self, other)      | 定义赋值取模算法的行为：%=     |
| __ ipow__(self, other)      | 定义赋值幂运算的行为：**=      |
| __ ilshift__(self, other)   | 定义赋值按位左移位的行为：<<=  |
| __ irshift__(self, other)   | 定义赋值按位右移位的行为：>>=  |
| __ iand__(self, other)      | 定义赋值按位与操作的行为：&=   |
| __ ixor__(self, other)      | 定义赋值按位异或操作的行为：^= |
| __ ior__(self, other)       | 定义赋值按位或操作的行为：丨=  |

------

## 一元操作符的魔法方法

| 魔法方法          | 定义                      |
| ----------------- | ------------------------- |
| __ pos__(self)    | 定义正号的行为：+x        |
| __ neg__(self)    | 定义负号的行为：-x        |
| __ abs__(self)    | 定义当被abs()调用时的行为 |
| __ invert__(self) | 定义按位求反的行为：~x    |

----------------------------------------

## 简单定制

基本要求

- 定制一个计时器的类
- start和stop方法代表启动计时和停止计时
- 假设计时器对象t1，print(t1)和直接调用t1均显示结果
- 当计时器未启动或已经停止计时，调用stop方法会给予温馨的提示
- 两个计时器对象可以进行相加：t1 + t2
- 只能使用提供的有限资源完成

```python
import time as t

class MyTimer:
    def __init__(self):
        self.unit = ['年', '月', '天', '小时', '分钟', '秒']
        self.prompt = "未开始计时！"
        self.lasted = []
        self.begin = 0
        self.end = 0

    # 开始计时
    def start(self):
        self.begin = t.localtime()
        self.prompt = "提示：请先调用stop()结束计时！"
        print("计时开始……")

    # 停止计时
    def stop(self):
        if not self.begin:
            print("提示：请先调用start()开始计时！")
        else:
            print("计时结束！")
            self.end = t.localtime()
            self._calc()
            
    # 内部方法，计算运行时间
    def _calc(self):
        self.lasted = []
        self.prompt = "总共运行了"
        for index in range(6):
            self.lasted.append(self.end[index] - self.begin[index])
            if self.lasted[index]:
                self.prompt += (str(self.lasted[index]) + self.unit[index])
        # 为下一轮计算初始化变量
        self.begin = 0
        self.end = 0
        print(self.prompt)

    # 调用实例直接显示结果
    def __str__(self):
        return self.prompt
    __repr__ = __str__

    # 计算两次计时器对象之和
    def __add__(self, other):
        prompt = "总共运行了"
        result = []
        for index in range(6):
            result.append(self.lasted[index] + other.lasted[index])
            if result[index]:
                prompt += (str(result[index]) + self.unit[index])
        return prompt

t1 = MyTimer()
t2 = MyTimer()
t1.start()
t.sleep(45)
t1.stop()
t2.start()
t.sleep(15)
t2.stop()
print(t1 + t2)
```

### timeit

通常在一段程序的前后都用上time.time()，然后进行相减就可以得到一段程序的运行时间，不过python提供了更强大的计时库：timeit

```python
#导入timeit.timeit
from timeit import timeit  

#看执行1000000次x=1的时间：
timeit('x=1')

#看x=1的执行时间，执行1次(number可以省略，默认值为1000000)：
timeit('x=1', number=1)

#看一个列表生成器的执行时间,执行1次：
timeit('[i for i in range(10000)]', number=1)

#看一个列表生成器的执行时间,执行10000次：
timeit('[i for i in range(100) if i%2==0]', number=10000)
```

测试一个函数的执行时间：

```swift
from timeit import timeit

def func():
    s = 0
    for i in range(1000):
        s += i
    print(s)

# timeit(函数名_字符串，运行环境_字符串，number=运行次数)
t = timeit('func()', 'from __main__ import func', number=1000)
print(t)
```

此程序测试函数运行1000次的执行时间

-----------

## 属性相关的魔法方法

| 魔法方法                        | 含义                                          |
| ------------------------------- | --------------------------------------------- |
| __ getattr__(self, name)        | 定义当用户试图获取一个不存在的属性时的行为    |
| __ getattribute__(self, name)   | 定义当该类的属性被访问时的行为(在getattr之前) |
| __ setattr__(self, name, value) | 定义当一个属性被设置时的行为                  |
| __ delattr__(self, value)       | 定义当一个属性被删除时的行为                  |

- 写一个矩形类，默认有宽和高两个属性；

- 如果为一个叫square的属性赋值，那么说明这是一个正方形，值就是正方形的边长，此时宽和高都应该等于边长

代码如下：

```python
class Rectangle():
    def __init__(self, width=0, height=0):
        self.width  = width
        self.height = height

    def __setattr__(self, name, value):
        if name == 'square':
            self.width  = value
            self.height = value
        else:
            super().__setattr__(name, value)
			#self.__dict__[name] = value
            
    def getArea(self):
        return self.width * self.height
```

属性魔法方法初学者容易犯死循环如何避免？

第一种：用super()来调用基类，比如：super().__setattr\_\_(name, value)

第二种：给特殊属性\_\_dict_\_赋值，它的作用是以字典的形式显示出当前对象的所有属性以及对应的值。比如：self.\_\_dict__[name] = value

-------------

## 描述符property()函数

**描述符就是将某种特殊类型的类的实例指派给另一个类的属性。**

`__get__(self, instance, owner)`

- 用于访问属性，它返回属性的值

`__set__(self, instance, value)`

- 将在属性分配操作中调用，不返回任何内容

`__delete__(self, instance)`

- 控制删除操作，不返回任何内容

```ruby
>>> class MyDescriptor:
    # self是描述符自身的实例；instance是这个描述符的拥有着所在类的实例，在这里也就是Test类的实例；owner是这个描述符的拥有者所在的类本身
    def __get__(self, instance, owner):
        print("getting...", self, instance, owner)
    # 参数value是等号右边的值，就是下面的'X-man'
    def __set__(self, instance, value):
        print("setting...", self, instance, value)
    def __delete__(self, instance):
        print("delete...", self, instance)

        
>>> class Test:
    x = MyDescriptor()
	#MyDescriptor()是MyDescriptor类的实例，指派给了Test类的x属性
    #MyDescriptor()就是x的描述符
    
>>> test = Test()
>>> test.x
getting... <__main__.MyDescriptor object at 0x000001A2EA6D86D8> <__main__.Test object at 0x000001A2EA668278> <class '__main__.Test'>
>>> test
<__main__.Test object at 0x000001A2EA668278>
>>> Test
<class '__main__.Test'>
>>> test.x = 'X-man'
setting... <__main__.MyDescriptor object at 0x000001A2EA6D86D8> <__main__.Test object at 0x000001A2EA668278> X-man
>>> del test.x
delete... <__main__.MyDescriptor object at 0x000001A2EA6D86D8> <__main__.Test object at 0x000001A2EA668278>
>>> 
```

### 自定义property

```ruby
>>> class MyProperty:
    def __init__(self, fget=None, fset=None, fdel=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
    def __get__(self, instance, owner):
        return self.fget(instance)
    def __set__(self, instance, value):
        self.fset(instance, value)
    def __delete__(self, instance):
        self.fdel(instance)

>>> class C:
    def __init__(self):
        self._x = None  # 你想声明为私有的方法和属性前加上单下划线,以提示该属性和方法不应在外部调用
    def getX(self):
        return self._x
    def setX(self, value):
        self._x = value
    def delX(self):
        del self._x
    x = MyProperty(getX, setX, delX)

>>> c = C()
>>> c.x = 'X-man'
>>> c.x
'X-man'
>>> c._x
'X-man'
>>> del c.x
>>> c._x
Traceback (most recent call last):
  File "<pyshell#32>", line 1, in <module>
    c._x
AttributeError: 'C' object has no attribute '_x'
>>> 
```

下面举一个摄氏与华氏相互转换的例子：

```ruby
>>> class Celsius:
    def __init__(self, value=26.0):
        self.value = float(value)
    def __get__(self, instance, owner):
        return self.value
    def __set__(self, instance, value):
        self.value = float(value)

        
>>> class Fahrenheit:
    def __get__(self, instance, owner):
        return instance.cel * 1.8 + 32
    def __set__(self, instance, value):
        instance.cel = (float(value) - 32) / 1.8

        
>>> class Temperature:
    cel = Celsius()
    fah = Fahrenheit()

    
>>> temp = Temperature()
>>> temp.cel
26.0
>>> temp.fah
78.80000000000001
>>> temp.fah = 100
>>> temp.cel
37.77777777777778
```

-------------

## 定制容器类相关的魔法方法

- 如果说你希望定制的容器是不可变的话，你只需要定义`__len__()`和`__getitem__()`方法。

- 如果你希望定制的容器是可变的话，除了`__len__()`和`__getitem__()`方法，你还需要定义`__setitem__()`和`__delitem__()`两个方法

| 魔法方法                       | 含义                                                  |
| ------------------------------ | ----------------------------------------------------- |
| __ len__(self)                 | 定义当被len()函数调用时的行为（返回容器中元素的个数） |
| __ getitem__(self, key)        | 定义获取容器中指定元素的行为，相当于self[key]         |
| __ setitem__(self, key, value) | 定义设置容器中指定元素的行为，相当于self[key]=value   |
| __ delitem__(self, key)        | 定义删除容器中指定元素的行为，相当于del self[key]     |
| __ iter__(self)                | 定义当迭代容器中的元素的行为                          |
| __ reversed__(self)            | 定义当被reversed()函数调用时的行为                    |
| __ contains__(self, item)      | 定义当使用成员测试运算符（in或not in）时的行为        |

-----------------

## 迭代器

### 迭代器的BIF

 `iter()`：返回迭代器本身；

 `next()`：返回下一个值，当迭代器没有可以返回的值了，就报StopIteration异常。

```python
>>> string = 'FishC'
>>> it = iter(string)
>>> next(it)
'F'
>>> next(it)
'i'
>>> next(it)
's'
>>> next(it)
'h'
>>> next(it)
'C'
>>> next(it)
Traceback (most recent call last):
  File "<pyshell#92>", line 1, in <module>
    next(it)
StopIteration
```

### 迭代器的魔法方法

 `__iter__()`：返回迭代器本身

 `__next__()`：这里写迭代的规律

```python
class Fibs:
    def __init__(self, n=20):
        self.a = 0
        self.b = 1
        self.n = n
    def __iter__(self):
        return self
    def __next__(self):
        self.a, self.b = self.b, self.a + self.b
        if self.a > self.n:
            raise StopIteration
        return self.a

fibs = Fibs(20)
for each in fibs:
    print(each)
```

输出：

```undefined
1
1
2
3
5
8
13
```

------------

## 测试题一

**0.是哪个特征让我们一眼就能认出这货是魔法方法？**

魔法方法总是被双下划线包围，例如`__init__`



**1.类实例化对象所谓用的第一个方法是什么？**

`__new__`是在一个对象实例化的时候所调用的第一个方法。它跟其他魔法方法不同，它的第一个参数不是self，而是这个类（cls），而其他参数会直接传递给`__int__()`方法的



**2.什么时候我们需要在类中明确写出__ init__()方法？**

当我们的实例对象需要有明确的初始化步骤的时候，你可以在`__init__`方法中部署初始化的代码

```python
# 我们定义一个矩形类，需要长和宽两个参数，拥有计算周长和面积两个方法。
#我们需要对象在初始化的时候拥有“长”和“宽”两个参数，因此我们需要重写__ init__方法
#因此我们说过，__ init__方法是类在实例化对象的时候首先调用的一个方法，大家可以理解吗？
>>> class Rectangle:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def getPeri(self):
        return (self.x + self.y) * 2
    def getArea(self):
        return self.x * self.y

    
>>> rect = Rectangle(3, 4)
>>> rect.getPeri()
14
>>> rect.getArea()
12
>>> 
```



**3.请问以下代码存在什么问题？**

```python
>>> class Test:
    def __init__(self, x, y):
        return x + y
```

编程中需要注意到`__init__()`方法的返回值一定是None，不能是其他



**4.请问__ new__()方法是负责什么任务？**

`__new__()`方法主要是在一个对象实例化时返回一个实例对象，通常是参数cls这个类的实例化对象，当然你也可以返回其他对象



**5.__ del__()魔法方法什么时候会被自动调用？**

如果说`__init__()`和`__new__()`方法是对象的构造器的话，那么Python也提供了一个析构器，叫做`__del__()`方法。当对象将要被销毁的时候，这个方法就会被调用

但一定要注意，并非del x就相当于自动调用`x.__del__()`方法，`__del__()`方法是当垃圾回收机制回收这个对象的时候调用的



**6.小李做事常常丢三落四的，写代码也是一样，常常打开文件又忘记关闭。你能不能写一个FileObject类，给文件对象进行包装，从而确认在删除对象时文件能自动关闭？**

```python
class FileObject:
    '''给文件对象进行包装从而确认在删除时文件流关闭'''
    def __init__(self, filename='record.txt'):
        # 读写模式打开一个文件
        self.new_file = open(filename, 'r+', encoding='utf-8')
    def __del__(self):
        self.new_file.close()
        del self.new_file
```



**7.按照以下要求，定义一个类实现摄氏度到华氏度的转换（转换公式：华氏度=摄氏度*1.8+32）**

要求：我们希望这个类尽量简练地实现功能。如下：

```python
>>> print(C2F(32))
89.6
```

为了尽量简练地实现功能，我们采取了“偷龙转凤”的小技巧。在类进行初始化之前，通过“掉包”arg参数，让实例对象直接返回计算后的结果。

代码如下

```python
class C2F(float):
    "摄氏度转换为华氏度"
    def __new__(cls, arg=0.0):
        return float.__new__(cls, arg * 1.8 + 32)
```



**8.定义一个类继承于int类型，并实现一个特殊功能：当传入的参数是字符串的时候，返回该字符串中所有字符的ASCII码的和（使用ord()获取一个字符的ASCII码值）**

```python
class Nint(int):
    def __new__(cls, arg=0):
        if isinstance(arg, str):
            total = 0
            for each in arg:
                total += ord(each)
            arg = total
        return int.__new__(cls, arg)

    
>>> print(Nint("ABCD"))
266
>>> print(Nint(123))
123
>>> print(Nint(1.9))
1
>>> print(Nint("I LOVE FISHC"))
812   
```

------------------

## 测试题二

**0.自从Python 2.2以后，对类和类型进行了统一，做法就是将int()、float()、str()、list()、tuple()这些BIF转换为工厂函数。请问所谓的工厂函数，其实是什么原理？**

工厂函数，其实就是一个类对象。当你调用他们的时候，事实上就是创建一个相应的实例对象



**1.当实例对象进行加法操作时，会自动调用什么魔法方法？**

对象a和b相加时（a+b），Python会自动根据对象a的`__add__()`魔法方法进行相加操作



**2.下边代码有问题吗？（运行起来好像没报错）**

```ruby
>>> class Foo:
    def foo(self):
        self.foo = "I love FishC.com!"
        return self.foo
      
>>> foo = Foo()   
>>> foo.foo()     
'I love FishC.com!'
```

这绝对是一个温柔的陷阱，这种BUG比较难以排查，所以一定要注意：类的属性名和方法名绝对不能相同！如果代码这么写，就会有一个难以排查的BUG出现了：

```ruby
>>> class Foo:
      def __init__(self):
          self.foo = "I love FishC.com!"
      def foo(self):
          return self.foo
      
>>> foo = Foo()   
>>> foo.foo()     
Traceback (most recent call last):
  File "<pyshell#120>", line 1, in <module>
    foo.foo()
TypeError: 'str' object is not callable  # 不能调用
```

注意：**如果类中的方法名和属性名相同，属性会覆盖方法**



**3.以下代码说明Python支持什么风格？**

```ruby
>>> def calc(a, b, c):
      return (a + b) * c
      
>>> a = calc(1, 2, 3)     
>>> b = calc([1, 2, 3], [4, 5, 6], 2)     
>>> c = calc('love', 'FishC', 3)      
>>> print(a)      
9
>>> print(b)      
[1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]
>>> print(c)      
loveFishCloveFishCloveFishC
```

说明Python支持鸭子类型（duck typing）风格。**我们并不关心对象是什么类型，到底是不是鸭子，只关心行为**



**4.我们都知道在Python中，两个字符串相加会自动拼接字符串，但遗憾的是两个字符串相减却抛出异常，因此，现在我们要求定义一个Nstr类，支持字符串的相减操作：A - B，从A中去除所有B的子字符串**

```ruby
>>> a = Nstr('I love FishC.com!iiiiiiiiiiiii')
>>> b = Nstr('i')
>>> a - b
'I love FshC.com!'
```

只需要重载__ sub__魔法方法即可。

```ruby
>>> class Nstr(str):
      def __sub__(self, other):
          return self.replace(other, '')
      
>>> a = Nstr("anckjcaevjeoicsvmskvbnsvm;alc,wvwenvoslv,eos")
>>> b = Nstr("a")     
>>> a - b     
'nckjcevjeoicsvmskvbnsvm;lc,wvwenvoslv,eos'
```



**5.移位操作符是应用于二进制操作数的，现在需要你定义一个新的类Nstr，也支持移位操作符的运算**

```ruby
>>> a = Nstr('I love FishC.com!')
>>> a << 3
'ove FishC.com!I l'
>>> a >> 3
'I love FishC.com!'
```

只需要重载__ lshift__ 和 __ rshift__魔法方法即可

```python
class Nstr(str):
    def __lshift__(self, other):
        return self[other:] + self[:other]
    def __rshift__(self, other):
        return self[-other:] + self[:-other]
```



**6.定义一个类Nstr，当该类的实例对象间发生的加、减、乘、除运算时，将该对象的所有字符串的ASCII码之和进行运算**

```python
class Nstr:
    def __init__(self, arg=''):
        if isinstance(arg, str):
            self.total = 0
            for each in arg:
                self.total += ord(each)
        else:
            print("参数错误")

    def __add__(self, other):
        return self.total + other.total

    def __sub__(self, other):
        return self.total - other.total

    def __mul__(self, other):
        return self.total * other.total

    def __truediv__(self, other):
        return self.total / other.total

    def __floordiv__(self, other):
        return self.total // other.total


a = Nstr('abc')
b = Nstr('def')
print(a + b)
print(a - b)
print(a * b)
print(a / b)
print(a // b)
```

输出

```css
597
-9
89082
0.9702970297029703
0
```

-------------

## 测试题三

**0.对象相加（a + b），如果a对象有\_\_add\_\_方法，请问b对象的 \_\_radd\_\_会被调用吗？**

不会！

```ruby
>>> class Nint(int):
    def __radd__(self, other):
        print("__radd__被调用了！")
        return int.__add__(self, other)
              
>>> a = Nint(5)           
>>> b = Nint(3)           
>>> a + b             
8
>>> 1 + b             
__radd__被调用了！
4
```



**1.Python什么时候会调用到反运算的魔法方法？**

例如 a + b，如果a对象的`__add__`方法没有实现或者不支持相应的操作，那么Python就会自动调用b的`__radd__`方法



**2.请问如何在继承的类中调用基类的方法？**

**使用super()这个BIF函数**

```ruby
class A(object):
    def __init__(self, a=0):
        self.a = a
    def get(self):
        return self.a

class B(A):
    def __init__(self, b):
        super(B, self).__init__(b)
    def get(self):
        return super(B, self).get()

if __name__ == '__main__':
    b = B(10)
    print(b.get())
```



**3.如果我要继承的基类是动态的（有时候是A，有时候是B），我应该如何部署我的代码，以便基类可以随意修改**

**你可以先为基类定义一个别名，在类定义的时候，使用别名代替你要继承的基类**。因此，当你想要改变基类的时候，只需要修改别名赋值的那个语句即可。顺便说一下，当你的资源是视情况而定的时候，这个小技巧很管用。

```ruby
BaseAlias = BaseClass  # 为基类取别名
 
class Derived(BaseAlias):
    def meth(self):
        BaseAlias.meth(self)  # 通过别名访问基类
        ...
```



**4.尝试自己举一个例子说明如何使用类的静态属性**

类的静态属性很简单，在类中直接定义的变量（没有self.）就是静态属性。**引用类的静态属性使用“类名.属性名”的形式**。

类的静态属性应用（计算该类被实例化的次数）：

```ruby
class C:
    count = 0  # 静态属性

    def __init__(self):
        C.count = C.count + 1  # 类名.属性名的形式引用

    def getCount(self):
        return C.count

c1 = C()
c2 = C()
print(c1.getCount())
```

输出：

```undefined
2
```



**5.尝试自己列举说明如何使用类中的静态方法，并指出使用静态方法有什么不同和哪些需要注意的地方？**

静态方法是类的特殊方法，**静态方法只需要在普通方法的前边加上@staticmethod修饰符即可**

```ruby
>>> class C:
    @staticmethod
    def static(arg1, arg2, arg3):
        print(arg1, arg2, arg3, arg1 + arg2 + arg3)

    def nostatic(self):
        print("I'm the fucking normal method!")

        
>>> c = C()
>>> c.static(1, 2, 3)
1 2 3 6
>>> c.nostatic()
I'm the fucking normal method!
>>>
```

**静态方法最大的优点是：不会绑定到实例对象上，换而言之就是节省开销**

```ruby
>>> c1 = C()
>>> c2 = C()
>>> c1.static is C.static
True
>>> c1.nostatic is C.nostatic
False
>>> c1.static
<function C.static at 0x0000018650FA1E18>
>>> c2.static
<function C.static at 0x0000018650FA1E18>
>>> C.static
<function C.static at 0x0000018650FA1E18>
# 普通方法每个实例对象都拥有独立的一个，开销较大
>>> c1.nostatic
<bound method C.nostatic of <__main__.C object at 0x00000186518F9A20>>
>>> c2.nostatic
<bound method C.nostatic of <__main__.C object at 0x0000018651968DD8>>
>>> C.nostatic
<function C.nostatic at 0x000001865196B1E0>
```

**使用的时候需要注意的地方：静态方法并不需要self参数，因此即使是使用对象去访问，self参数也不会传进去**

```ruby
>>> c.static(1, 2, 3)
1 2 3 6
>>> C.static(1, 2, 3)
1 2 3 6
```



**6.定义一个类，当实例化该类的时候，自动判断传入了多少个参数，并显示出来**

```python
>>> class C:
    def __init__(self, *args):
        if not args:
            print("并没有传入参数")
        else:
            print("传入了%d个参数，分别是：" % len(args), end=' ')
            for each in args:
                print(each, end=' ')

                
>>> c = C(1, 2, 3)
传入了3个参数，分别是： 1 2 3 
```



**7.定义一个单词（Word）类继承自字符串，重写比较操作符，当两个Word类对象进行比较时，根据单词的长度来进行比较大小**。

加分要求：实例化时如果传入的是带空格的字符串，则取第一个空格前的单词作为参数

加分要求可以通过重载`__new__`方法来实现（因为字符串是不可变类型），通过重写`__gt__`、`__lt__`、`__ge__`、`__le__`方法来定义Word类在比较操作中的表现。

注意：我们没有定义`__eq__`和`__ne__`方法。这是因为将会产生一些怪异不符合逻辑的结果（例如Word('FishC'）会等于Word('Apple'))

代码如下：

```python
class Word(str):
    '''存储单词的类，定义比较单词的几种方法'''
    def __new__(cls, word):
        # 注意我们必须要用到__new__方法，因为str是不可变类型
        # 所以我们必须在创建的时候将它初始化
        if ' ' in word:
            print("Value contains spaces. Truncating to first space.")
            word = word[:word.index(' ')]  # 单词是第一个空格之前的所有字符
        return str.__new__(cls, word)

    def __gt__(self, other):
        return len(self) > len(other)

    def __lt__(self, other):
        return len(self) < len(other)

    def __ge__(self, other):
        return  len(self) >= len(other)

    def __le__(self, other):
        return len(self) <= len(other)

w1 = Word('abcd')
w2 = Word('abca vsdv')
if w1 >= w2:
    print(True)
```

输出：

```php
Value contains spaces. Truncating to first space.
True
```

--------

## 测试题四

**0.按照课堂中的程序，如果开始计时的时间为（2022年2月22日16:30:30），停止时间是（2025年1月23日15:30:30），那按照我们用停止时间减去开始时间的计算方式就会出现负数，你应该对此做一些转换**

```python
import time as t


class MyTimer:
    def __init__(self):
        self.unit = ['年', '月', '天', '小时', '分钟', '秒']
        self.borrow = [1, 12, 31, 24, 60, 60]
        self.prompt = "未开始计时！"
        self.lasted = []
        self.begin = 0
        self.end = 0

    # 开始计时
    def start(self):
        self.begin = t.localtime()
        self.prompt = "提示：请先调用stop()结束计时！"
        print("计时开始……")

    # 停止计时
    def stop(self):
        if not self.begin:
            print("提示：请先调用start()开始计时！")
        else:
            self.end = t.localtime()
            self._calc()
            print("计时结束！")

    # 内部方法，计算运行时间
    def _calc(self):
        self.lasted = []
        self.prompt = "总共运行了"
        for index in range(6):
            temp = self.end[index] - self.begin[index]
            # 低位不够减，需要向高位借位
            if temp < 0:
                # 测试高位是否有得借，没得借的话再向高位借……
                i = 1
                while self.lasted[index-i] < 1:
                    self.lasted[index-i] += self.borrow[index-i] - 1
                    self.lasted[index-i-1] -= 1
                    i += 1
                self.lasted.append(self.borrow[index] + temp)
                self.lasted[index-1] -= 1
            else:
                self.lasted.append(temp)

        # 由于高位随时会被借位，所以打印要放在最后
        for index in range(6):
            if self.lasted[index]:
                self.prompt += str(self.lasted[index]) + self.unit[index]

        # 为下一轮计算初始化变量
        self.begin = 0
        self.end = 0
        print(self.prompt)

    # 调用实例直接显示结果
    def __str__(self):
        return self.prompt
    __repr__ = __str__

    # 计算两次计时器对象之和
    def __add__(self, other):
        prompt = "总共运行了"
        result = []
        for index in range(6):
            result.append(self.lasted[index] + other.lasted[index])
            if result[index]:
                prompt += (str(result[index]) + self.unit[index])
        return prompt

t1 = MyTimer()
t2 = MyTimer()
t1.start()
t.sleep(65)
t1.stop()
t2.start()
t.sleep(15)
t2.stop()
print(t1 + t2)
```



**1.相信大家已经意识到不对劲了：为毛一个月一定是31天？不知道可能也是30天或者29天吗？（上一题我们的答案是假设一个月31天）。没错，如果要正确得到月份的天数，我们还需要考虑是否闰年，还有每月的最大天数，所以太麻烦了……如果我们不及时就在，我们会在错误的道路上越走越远……**

所以，这一次，小甲鱼提出了更优秀的解决方案（Python官方推荐）：用time模块的perf_counter()和process_time()计算，其中**perf_counter()返回计时器的精准时间（系统的运行时间）**；process_time()返回当前进程执行CPU的时间总和。

题目：改进我们课堂中的例子，这次使用perf_counter()和process_time()作为计时器，另外新增一个set_time()方法，用于设置默认计时器（默认是perf_counter()，可以通过此方法修改为process_time() ）

```python
import time as t


class MyTimer:
    def __init__(self):
        self.prompt = "未开始计时"
        self.lasted = 0.0
        self.begin = 0
        self.end = 0
        self.default_timer = t.perf_counter
    def __str__(self):
        return self.prompt
    __repr__ = __str__
    def __add__(self, other):
        result = self.lasted + other.lasted
        prompt = "总共运行了%0.2f秒" % result
        return prompt
    def start(self):
        self.begin = self.default_timer()
        self.prompt = "提示：请先调用stop()停止计时！"
        print("计时开始！")
    def stop(self):
        if not self.begin:
            print("提示：请先调用start()运行计时！")
        else:
            self.end = self.default_timer()
            self._calc()
            print("计时结束")
    def _calc(self):
        self.lasted = self.end - self.begin
        self.prompt = "总共运行了%0.2f秒" % self.lasted
        print(self.prompt)
        self.begin = 0
        self.end = 0

    def set_timer(self, timer):
        if timer == 'process_time':
            self.default_timer = t.process_time
        elif timer == 'perf_counter':
            self.default_timer = t.perf_counter
        else:
            print("输入无效")



t1 = MyTimer()
t1.set_timer('perf_counter')
t1.start()
t.sleep(5.2)
t1.stop()
t2 = MyTimer()
t2.set_timer('perf_counter')
t2.start()
t.sleep(5.2)
t2.stop()
print(t1 + t2)
```

输出：

```css
计时开始！
总共运行了5.20秒
计时结束
计时开始！
总共运行了5.20秒
计时结束
总共运行了10.40秒
```



**2.既然咱都做到了这一步，那不如再深入以下，再次改进我们的代码，让它能够统计一个函数运行若干次的时间**

要求一：函数调用的次数可以设置（默认是1000000次）
要求二：新增一个timing()方法，用于启动计时器

```python
import time as t

class MyTimer:
    def __init__(self, func, number=1000000):
        self.prompt = "未开始计时"
        self.lasted = 0.0
        self.default_timer = t.perf_counter
        self.func = func
        self.number = number
    def __str__(self):
        return self.prompt
    __repr__ = __str__
    def __add__(self, other):
        result = self.lasted + other.lasted
        prompt = "总共运行了%0.2f秒" % result
        return prompt
    # 内置方法，计算运行时间
    def timing(self):
        self.begin = self.default_timer()
        for i in range(self.number):
            self.func()
        self.end = self.default_timer()
        self.lasted = self.end - self.begin
        self.prompt = "总共运行了 %0.2f 秒" % self.lasted

    def set_timer(self, timer):
        if timer == 'process_time':
            self.default_timer = t.process_time
        elif timer == 'perf_counter':
            self.default_timer = t.perf_counter
        else:
            print("输入无效")

def test():
    text = "I love FishC.com!"
    char = 'o'
    if char in text:
        pass

t1 = MyTimer(test)
t1.timing()
print(t1)
t2 = MyTimer(test, 100000000)
t2.timing()
print(t2)
```

输出：

```css
总共运行了 0.10 秒
总共运行了 9.96 秒
```

--------

## 测试题五

**0.请问以下代码的作用是什么？这样写正确吗？（如果不正确，请改正）**

```python
def __setattr__(self, name, value):
        self.name =  value + 1
```

这段代码试图在对象的属性发生赋值操作的时候，将实际的值+1赋值给相应的属性。但这么写法是错误的，因为每当属性被赋值的时候，`__setattr__()`会被调用，而里面的self.name = value + 1语句又会再次触发`__setattr__()`调用，导致无限递归。

正确地写法：

```python
def __setattr__(self, name, value):
        self.__dict__[name]  =  value + 1
或
def __setattr__(self, name, value):
		super().__setattr__() =  value + 1
```



**1.自定义该类的属性被访问的行为，你应该重写哪个魔法方法？**

`__getattribute__(self, name)`



**2.在不上机验证的情况下，你能推断以下代码会显示什么吗？**

```ruby
>>> class C:
    def __getattr__(self, name):
        print(1)
    def __getattribute__(self, name):
        print(2)
    def __setattr__(self, name, value):
        print(3)
    def __delattr__(self, name):
        print(4)

        
>>> c = C()
>>> c.x = 1
# 位置一，请问这里会显示什么？
>>> print(c.x)
#位置二，请问这里会显示什么？
```

答：

```ruby
>>> c = C()
>>> c.x = 1
3
>>> print(c.x)
2
None
```

位置一会显示3，因为c.x = 1是赋值操作，所以会访问`__setattr__()`魔法办法；

位置二会显示2和None。因为x是属于实例对象c的属性，所以c.x是访问一个存在的属性，因此会访问`__getattribute__()`魔法方法。但是我们重写了这个方法，使得它不能按照正常的逻辑返回属性值，而打印一个2代替。**由于我们没有写返回值，所以紧接着返回None并被print()打印出来**



**3.在不上机验证的情况下，你能推断以下代码会显示什么吗？**

```ruby
>>> class C:
      def __getattr__(self, name):
          print(1)
          return super().__getattr__(name)
      def __getattribute__(self, name):
          print(2)
          return super().__getattribute__(name)
      def __setattr__(self, name, value):
          print(3)
          super().__setattr__(name, value)
      def __delattr__(self, name):
          print(4)
          super().__delattr__(name)

      
>>> c = C()
      
>>> c.x
```

输出如下：

```ruby
>>> c.x   
2
1
Traceback (most recent call last):
  File "<pyshell#288>", line 1, in <module>
    c.x
  File "<pyshell#286>", line 4, in __getattr__
    return super().__getattr__(name)
AttributeError: 'super' object has no attribute '__getattr__'
>>> 
```

分析：首先c.x会调用`__getattribute__()`魔法方法，打印2；然后调用`super().__getattribute__()`，发现找不到属性名x，因此紧接着调用`__getattr__()`，于是打印1；

但是，你猜到了开头却猜不到结局……当你希望最后以`super().__getattr__()`终了的时候，Python竟然告诉你AttributeError，**super对象木有__ getattr__！！**

求证：

```ruby
>>> dir(super)
      
['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__self__', '__self_class__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__thisclass__']     
```



**4.请指出以下代码的问题所在：**

```ruby
>>> class Counter:
    def __init__(self):
        self.counter = 0
    def __setattr__(self, name, value):
        self.counter += 1
    def __delattr__(self, name):
        self.counter -= 1
        super().__delattr__(name)
```

答

```ruby
>>> class Counter:
    def __init__(self):
        self.counter = 0  # 这里会触发__setattr__调用
    def __setattr__(self, name, value):
#既然需要__setattr__调用才能真正设置self.counter的值，所以这个时候self.counter还没有定义，所以没法+1，错误的根源
        self.counter += 1
    def __delattr__(self, name):
        self.counter -= 1
        super().__delattr__(name)
```

修改如下： 

```ruby
>>> class Counter:
    def __init__(self):
        self.counter = 0
    def __setattr__(self, name, value):
        super().__setattr__(name, value+1)
    def __delattr__(self, name):
        self.counter -= 1
        super().__delattr__(name)
     
>>> c = Counter()
>>> c.counter = 1
>>> c.counter
2
>>> c.counter = 2
>>> c.counter
3
```



**5.按要求重写魔法方法：访问一个不存在的属性时，不报错并且提示“该属性不存在！”**

```ruby
>>> class Demo():
    def __getattr__(self, name):
        return '该属性不存在！'

    
>>> d = Demo()
>>> d.x
'该属性不存在！'
```



**6.编写Demo类，使得下边代码可以正常运行：**

```ruby
>>> demo = Demo()
>>> demo.x
'FishC'
>>> demo.x = "X-man"
>>> demo.x
'X-man'
```

答：

```ruby
>>> class Demo:
    def __getattr__(self, name):
        self.name = 'FishC'
        return self.name
    
>>> demo = Demo()
>>> demo.x
'FishC'
>>> demo.x = "X-man"
>>> demo.x
'X-man'
```



**7.修改第4题，使之可以正常运行；编写一个Counter类，用于实时检测对象有多少个属性**

程序实现如下：

```ruby
>>> c = Counter()
>>> c.x = 1
>>> c.counter
1
>>> c.y = 1
>>> c.z = 1
>>> c.counter
3
>>> del c.x
>>> c.counter
2
```

答

```ruby
>>> class Counter:
    def __init__(self):
        super().__setattr__('counter', 0)
    def __setattr__(self, name, value):
        super().__setattr__('counter', self.counter + 1)
        super().__setattr__(name, value)
    def __delattr__(self, name):
        super().__setattr__('counter', self.counter - 1)
        super().__delattr__(name)
```

-------

## 测试题六

**0.请尽量用作自己的语言来解释什么是描述符？**

有时候，某个应用程序可能会有一个相当微妙的需求，需要你设计一些更加复杂的操作来相应（例如每当属性被访问时，你也许想创建一个日志记录）。最好的解决方案就是编写一个用于执行这些“更复杂的操作”的特殊函数，然后指定它在属性被访问时运行。那么一个具有这种函数的对象被称为描述符



**1.描述类中，分别通过哪些魔法方法来实现对属性的get、set和delete操作的？**

描述类相关的魔法方法，见下表：

| 魔法方法                        | 含义                                   |
| ------------------------------- | -------------------------------------- |
| __ get__(self, instance, owner) | 用于访问属性，它返回属性的值           |
| __ set__(self, instance, value) | 将在属性分配操作中调用，不返回任何内容 |
| __ delete__(self, instance)     | 控制删除操作，不返回任何内容           |



**2.请问以下代码，分别调用test.a和test.x，哪个会打印“getting…”**

```ruby
>>> class MyDes:
    def __get__(self, instance, owner):
        print("getting...")
        
>>> class Test:
    a = MyDes()
    x = a
    
>>> test = Test()
```

都会打印的

```ruby
>>> test.a
getting...
>>> test.x
getting...
```



**3.请问以下代码会打印什么内容？**

```ruby
class MyDes:
    def __init__(self, value = None):
        self.val = value

    def __get__(self, instance, owner):
        return self.val - 20

    def __set__(self, instance, value):
        self.val = value + 10
        print(self.val)


class C:
    x = MyDes()

if __name__ == '__main__':
    c = C()
    c.x = 10
    print(c.x)
```

需要注意的是print(c.x)访问了c的x属性，因此值减20

```undefined
20
0
```



**4.请问以下代码会打印什么内容？**

```ruby
>>> class MyDes:
    def __init__(self, value = None):
        self.val = value
    def __get__(self, instance, owner):
        return self.val ** 2

    
>>> class Test:
    def __init__(self):
        self.x = MyDes(3)

        
>>> test = Test()
>>> test.x
```

打印如下：

```css
>>> test.x
<__main__.MyDes object at 0x000001A2EA668278>
```

如你所见，**访问实例层次上的描述符x，只会返回描述符本身**。**为了让描述符能够正常工作，它们必须定义在类的层次上**。如果你不这样做，那么Python无法自动为你调用`__get__`和`__set__`方法。

正确如下：

```ruby
>>> class MyDes:
    def __init__(self, value = None):
        self.val = value
    def __get__(self, instance, owner):
        return self.val ** 2

    
>>> class Test:
    x = MyDes(3)

    
>>> test = Test()
>>> test.x
9
```



**5.按要求编写描述符MyDes：当类的属性被访问、修改或设置的时候，分别作出提醒**

这里的描述符起到的作用是间接地保存指定变量的数据

```python
class MyDes:
    def __init__(self, initval=None, name=None):
        self.val = initval
        self.name = name

    def __get__(self, instance, owner):
        print("正在获取变量：", self.name)
        return self.name

    def __set__(self, instance, value):
        print("正在修改变量：", self.name)
        self.name = value

    def __delattr__(self, instance):
        print("正在删除变量：", self.name)
        print("┗|｀O′|┛ 嗷~~这个变量没法删除~")
```



**6.按要求编写描述符MyDes：记录指定变量的读取和写入操作，并将记录以及触发时间保存到文件**

```python
import time

class Record:
    def __init__(self, initval=None, name='x'):
        self.val = initval
        self.name = name
        self.filename = "record.txt"

    def __get__(self, instance, owner):
        with open(self.filename, 'a', encoding='utf-8') as f:
            f.write("%s 变量于北京时间 %s 被读取，%s = %s\n" % \
                    (self.name, time.ctime(), self.name, str(self.val)))
        return self.val

    def __set__(self, instance, value):
        filename = "%s_record.txt" % self.name
        with open(self.filename, 'a', encoding='utf-8') as f:
            f.write("%s 变量于北京时间 %s 被修改，%s = %s\n" % \
                    (self.name, time.ctime(), self.name, str(value)))
        self.val = value
```



**7.编写描述符MyDes，使用文件来存储属性，属性的值会直接存储到对应的pickle的文件中。如果属性被删除了，文件也会同时被删除，属性的名字也会被注销**

```python
import os
import pickle

class MyDes:
    saved = []

    def __init__(self, name='11'):
        self.name = name
        self.filename = self.name + '.pkl'

    def __get__(self, instance, owner):
        if self.name not in MyDes.saved:
            raise AttributeError("%s 属性还没有赋值！" % self.name)

        with open(self.filename, 'rb') as f:
            value = pickle.load(f)

        return value

    def __set__(self, instance, value):
        with open(self.filename, 'wb') as f:
            pickle.dump(value, f)
            MyDes.saved.append(self.name)

    def __delete__(self, instance):
        os.remove(self.filename)
        MyDes.saved.remove(self.name)

class Test:
    x = MyDes()

test = Test()
test.x = 10
```

----------------------

## 测试题七

**0.你知道Python基于序列的三大容器类指的是什么吗？**

列表（List）、元组（Tuple）、字符串（String）



**1.Python允许我们自己定义容器，如果你想要定制一个不可变的容器（像String），你就不能定义什么方法？**

如果你想要定制一个不可变的容器，你就不能定义像`__setitem__()`和`__delitem__()`方法，这两个会修改容器中的数据的方法



**2.如果希望定制的容器支持reversed()内置方法，那么你应该定义什么方法？**

应该定义`__reversed__()`方法，提供对内置函数reversed()的支持



**3.既然是容器，必须要提供能够查询“容器”的方法，那么请问需要定义什么方法呢？**

在Python中，我们通过len()内置函数来查询容器的“容量”，所以容器应该定义`__len__()`方法



**4.通过定义哪些方法使得容器支持读、写和删除的操作？**

读是`__getitem__()`；写是`__setitem__()`；删除时`__delitem__()`



**5.为什么小甲鱼说“在Python中的协议就显得不那么正式？”**

在Python中，协议更像一种指南。这点像我们之前在课后作业中提到的“鸭子类型”。当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。Python就是这样，并不会严格要求你一定要怎样去做，而是让你靠着自觉和经验把事情做好



**6.根据课堂上的例子，定制一个列表，同样要求记录列表中每个元素被访问的次数，这一次我们希望定制的列表功能更加全面一些，比如支持append()、pop()、extend()原生列表所拥有的方法。你应该如何修改呢？**

要求1：实现获取、设置和删除一个元素的行为（删除一个元素的时候对应的计数器也会被删除）

要求2：增加counter(index)方法，返回index参数所指定的元素次数的访问次数

要求3：实现append()、pop()、remove()、insert()、clear()和reverse()方法（重写这些方法时注意考虑计数器的对应改变）

答：我们先看下课堂上的例子：

```ruby
>>> class CountList:
    def __init__(self, *args):  # 可变数量的参数
        self.values = [x for x in args]  # 把参数转换成列表
        self.count = { }.fromkeys(range(len(self.values)), 0)  # 给字典初始化
        # 这里是有列表的下表作为字典的键，注意不能用元素作为字典的键
        # 因为列表的不同下标可能有值一样的元素，但字典不能有两个相同的键
    def __len__(self):
        return len(self.values)
    def __getitem__(self, key):
        self.count[key] += 1
        return self.values[key]

    
>>> c1 = CountList(1, 3, 5, 7, 9)
>>> c2 = CountList(2, 4, 6, 8, 10)
>>> c1[1]
3
>>> c2[1]
4
>>> c1[1] + c2[2]
9
>>> c1.count
{0: 0, 1: 2, 2: 0, 3: 0, 4: 0}
>>> c2.count
{0: 0, 1: 1, 2: 1, 3: 0, 4: 0}
```

为了实现那么多的功能，我们不能再用字典来存放元素的计数了，因为对于列表来说，如果你删除其中一个元素，那么其他元素的下标都会发生相应的变化（利用下标作为键的字典肯定就不能应对自如）。因此，我们改用一个列表来存放对应的元素的计数。

下边是CountList类继承并严重依赖其父类（list）的行为，并按要求重写了一些方法。

代码清单

```ruby
class CountList(list):
    def __init__(self, *args):
        super().__init__(args)
        self.count = []
        for i in args:
            self.count.append(0)

    def __len__(self):
        return len(self.count)

    def __getitem__(self, key):
        self.count[key] += 1
        return super().__getitem__(key)

    def __setitem__(self, key, value):
        self.count[key] += 1
        super().__setitem__(key, value)

    def __delitem__(self, key):
        del self.count[key]
        super().__delitem__(key)

    def counter(self, key):  # 根据下标返回访问的次数
        return self.count[key]

    def append(self, value):
        self.count.append(0)
        super().append(value)

    def pop(self, key=-1):
        del self.count[key]
        return super().pop(key)

    def remove(self, value):
        key = super().index(value)
        del self.count[key]
        super().remove(value)

    def insert(self, key, value):
        self.count.insert(key, 0)
        super().insert(key, value)

    def clear(self):
        self.count.clear()
        super().clear()

    def reverse(self):
        self.count.reverse()
        super().reverse()

c1 = CountList(1, 2, 3, 4, 5, 6)
c1[1]
c1[1]
c1[1]
print(c1)
print(c1.count)
print("*"*30)
print(c1.counter(1))
print("*"*30)
c1.append(99)
print(c1)
print(c1.count)
print("*"*30)
c1.pop()
print(c1)
print(c1.count)
print("*"*30)
c1.remove(5)
print(c1)
print(c1.count)
print("*"*30)
c1.insert(2, 55)
print(c1)
print(c1.count)
print("*"*30)
c1.reverse()
print(c1)
print(c1.count)
print("*"*30)
c1.clear()
print(c1)
print(c1.count)
```

输出：

```csharp
[1, 2, 3, 4, 5, 6]
[0, 3, 0, 0, 0, 0]
******************************
3
******************************
[1, 2, 3, 4, 5, 6, 99]
[0, 3, 0, 0, 0, 0, 0]
******************************
[1, 2, 3, 4, 5, 6]
[0, 3, 0, 0, 0, 0]
******************************
[1, 2, 3, 4, 6]
[0, 3, 0, 0, 0]
******************************
[1, 2, 55, 3, 4, 6]
[0, 3, 0, 0, 0, 0]
******************************
[6, 4, 3, 55, 2, 1]
[0, 0, 0, 0, 3, 0]
******************************
[]
[]
```

-----------------

## 测试题八

**0.请用你的话解释一下“迭代”的概念**

迭代是重复反馈过程的活动，其目的通常是为了接近并到达所需的目标或结果。每一次对过程的重复被称为一次迭代，而每一次迭代得到的结果会被用来作为下一次迭代的初始值



**1.迭代器是一个容器吗？**

不是。因为我们耳熟能详的容器像列表、字典、元组都是可以存放数据的，而迭代器就是实现了`__next__()`方法的对象（用于遍历容器中的数据）



**2.迭代器可以回退（获取上一个值）吗？**

迭代器性质决定没有办法回退，只能往前进行迭代。但这并不是什么很大的缺点，因为我们几乎不需要再迭代途中进行回退操作



**3.如何快速判断一个容器是否具有迭代功能？**

判断该容器是否拥有`__iter__()`和`__next__()`魔法方法



**5.在Python原生支持的数据结构中，你知道哪一个是只能用迭代器访问的吗？**

对于原生支持随机访问的数据结构（如tuple、list），迭代器和经典for循环的索引访问相比并无优势，反而丢失了索引值（可以使用内建函数enumerate()找回这个索引值，这是后话）。但对于无法随机访问的数据结构（比如集合set）而言，迭代器是唯一的访问元素的方式



**6.用while语句实现以下for 语句相同的功能：**

```python
for each in range(5):
    print(each)
```

```python
>>> list1 = range(5)
>>> a = iter(list1)
>>> while True:
	try:
		print(next(a))
	except StopIteration:
		break

	
0
1
2
3
4
```



**7.写一个迭代器，要求输出至今为止的所有闰年。**

```python
import datetime as dt

class LeapYear:
    def __init__(self):
        self.now = dt.date.today().year

    def isLeapYear(self, year):
        if (year%4 == 0 and year%100 != 0) or (year%400 == 0):
            return True
        else:
            return False

    def __iter__(self):
        return self

    def __next__(self):
        while not self.isLeapYear(self.now):
            self.now -= 1

        temp = self.now
        self.now -= 1

        return temp

ly = LeapYear()
for i in ly:
    if i > 2000:
        print(i)
    else:
        break
```



**8.要求自己写一个MyRev类，功能与reversed()相同（内置函数reversed(seq)，是返回一个迭代器，是序列seq的逆序显示）**

```python
>>> myRev = MyRev("FishC")
>>>for i in myRev:
      print(i, end=' ')
        
C h s i F 
```

答

```python
class MyRev:
    def __init__(self, data):
        self.data = data
        self.index = len(data)

    def __iter__(self):
        return self

    def __next__(self):
        if self.index == 0:
            raise StopIteration

        self.index = self.index - 1
        return self.data[self.index]

myRev = MyRev("FishC")
for i in myRev:
    print(i, end=' ')
```